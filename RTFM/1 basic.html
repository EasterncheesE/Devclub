<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Основы</title>
    <link rel="stylesheet" href="https://dl.dropboxusercontent.com/u/31437201/article.css">
</head>
<body>
    <article class="page">
        <h1>Основы</h1>
        <aside class="plan">
            <div class="contents">
                <h2>План</h2>
                <ol>
                    <li><a href="#const">Константы</a></li>
                    <li><a href="#macros">Макросы</a></li>
                    <li><a href="#var">Переменные</a></li>
                    <li><a href="#data_types">Типы данных</a></li>
                    <li><a href="#operators">Операторы</a></li>
                </ol>
            </div>
            <div class="links">
            </div>
        </aside>

        <section>
            <h2 id="const">Константы</h2>
            <p>Чтобы узнать, что такое константа, обратимся к Википедии:</p>
            <blockquote cite="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"><dfn>Константа</dfn> в программировании — способ адресования данных, изменение которых рассматриваемой программой не предполагается или запрещается.
            </blockquote>
            <p>Смысл константы в программировании мало отличается от константы в общем понимании этого слова — это некая величина, которая не меняет своё значение в рамках рассматриваемого процесса. Простейший пример использования константы:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    printf("%d\n", 5); // если чё, "5" — это константа

    return 0;
}</code>
            <p>Проще говоря, константа — это данные, которые не будут меняться во время выполнения программы. Чтобы как-нибудь идентифицировать эти константы (а их может оказаться многовато) им присваивают имена. После такого акта невиданной щедрости, говорят, что константа <em>именованная</em>. Это даёт ряд преимуществ:</p>
            <ul>
                <li>позволяет избавиться от «<a href="http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)#.D0.9F.D0.BB.D0.BE.D1.85.D0.B0.D1.8F_.D0.BF.D1.80.D0.B0.D0.BA.D1.82.D0.B8.D0.BA.D0.B0_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F" target="_blank">магических чисел</a>», вроде пятёрки в предыдущем примере;</li>
                <li>повышается надёжность и безошибочность программы.</li>
            </ul>
            <p>Пример именованной константы в коде:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    const int magicNumber = 42;

    printf("%d\n", magicNumber);

    return 0;
}</code>
            <p>Для того, чтобы объявить константу используется служебное слово <code>const</code>, указывается тип данных константы (чтобы было понятно, сколько нужно памяти для её хранения) и имя константы.</p>
            <p>Константе нужно присвоить значение во время объявления, иначе потом сделать это не получится, ведь это константа — она неизменна по ходу работы программы.</p>
            <p>Пример объявления констант:</p>
            <code data-lang="c">const int          magicNumber     = 42;
const float        pi              = 3.141592;
const &lt;тип данных&gt; &lt;имя константы&gt; = &lt;значение&gt;;</code>
            <p>Очень важно давать константам подходящие имена, отражающие их суть. Иначе они будут мало чем отличаться от «магических чисел» неизвестного назначения и смысл их существования потеряется в безумстве именований.</p>
            <div class="co">Константа — это не переменная, её изменять нельзя.</div>
            <p>Суть константы — хранить значения, но эти значения не могут меняться в ходе программы, поэтому не стоит пытаться этого делать:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    const int magicNumber = 42;

    magicNumber = magicNumber + 1;

    printf("%d\n", magicNumber);

    return 0;
}</code>
            <samp>error: read-only variable is not assignable
    magicNumber = magicNumber + 1;
    ~~~~~~~~~~~ ^
1 error generated.</samp>
            <p>Это все равно, что написать <code>42 = 42 + 1</code> — как-то не сходится матан.</p>
            <img src="https://dl.dropboxusercontent.com/u/31437201/Articles/img/const.gif" alt="named constants">
        </section>

        <section>
            <h2 id="macros">Макросы</h2>
            <p><dfn>Макрос</dfn> (англ. <em>macro</em>, от <em>macroinstruction</em>) — это правило или же шаблон, который определяет, во что должна превратиться определённая буквенная последовательность после обработки <a href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80_%D0%A1%D0%B8" target="_blank">препроцессором</a>.</p>
            <p>Чтобы объявить макрос, нужно написать специальную конструкцию (<em>директиву</em>) <code>#define</code>, имя макроса (та самая буквенная последовательность) и значение, на которое будет заменено имя макроса во время работы препроцессора. Причём значение макроса не обязательно задавать в самой программе. Пример объявления макросов:</p>
            <code data-lang="c">#define MAGIC_NUMBER  42
#define PI            3.141592
#define &lt;имя макроса&gt; &lt;значение&gt;</code>
            <p class="notabene">Имя макроса принято писать заглавными буквами.</p>
            <p>С помощью макроса в программе можно заменить что угодно:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

#define BEGIN    int main() {
#define END      return 0; }
#define PRINT    printf("%d\n", 
#define ENDPRINT );

BEGIN
    PRINT 42 ENDPRINT
END</code>
            <p>Это работает — проверьте у себя. Всё что делает макрос — это подменяет одно значение на другое перед компиляцией. Недосток макроса в том, что можно «заиграться» и код Си станет чем угодно, только не кодом. Также нужно самостоятельно следить, какое значение макроса какому типу данных будет сопоставлено, иначе можно получить предупреждение и неожиданный результат:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

#define MAGIC_NUMBER 42.5

int main() {
    printf("%d\n", MAGIC_NUMBER);

    return 0;
}</code>
            <samp>1593863328</samp>
            <p>Для сравнения, приведем тот же пример, но с именованной константой:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    const float magicNumber = 42.5; // тут уже четко видно, какой тип данных

    printf("%f\n", magicNumber); // под float нужен шаблон %f

    return 0;
}</code>
            <samp>42.500000</samp>
            <p>Как уже упоминалось выше, значение макроса можно задать не только из самой программы, но и из консоли, это бывает очень удобно. В таком случае, в коде не нужно писать <code>#define</code>:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    printf("%d\n", NUMBER);

    return 0;
}</code>
            <p>А компиляция производится со специальным ключом <code>-D</code>, после которого указываем имя макроса и его значение:</p>
            <kbd>gcc macros.c -D NUMBER=100500</kbd>
        </section>

        <section>
            <h2 id="var">Переменные</h2>
            <p>Википедия, твой ход!</p>
            <blockquote cite="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"><dfn>Переменная</dfn> в императивном программировании — поименованная, либо адресуемая иным способом область памяти, адрес которой можно использовать для осуществления доступа к данным. Данные, находящиеся в переменной (то есть по данному адресу памяти), называются значением этой переменной.</blockquote>
            <p>Страшное определение. Попробуем разобраться, что имеется в виду.</p>
            <ul>
                <li>У переменной есть имя. Это должно быть адекватное имя.</li>
                <li>Переменная — это область памяти.</li>
                <li>Данные, которые хранит эта область памяти — это значение переменной.</li>
                <li>Переменную можно считывать и, в отличии от константы, перезаписывать.</li>
            </ul>
            <p>Простейший пример переменной со случайным числом в качестве значения:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int x = 42;

    x = x + 1; // перезапись переменной

    printf("%d\n", x);

    return 0;
}</code>
            <samp>43</samp>
            <p>Как видно из примера, чтобы получить значение переменной, не нужно указывать какие-то адреса, достаточно обратиться к ней по имени. Безотказный способ.</p>
            
            <h3>Объявление переменной</h3>
            <p>Чтобы иметь возможность использовать переменную в своём коде, её как минимум нужно объявить. Выглядит это так:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int x;
    int a, b, c, d;

    return 0;
}</code>
            <p>Схожие по смыслу переменные одного типа можно объявлять в одну строку, как показано в примере, строка 5.</p>
            <p>После этого можно пользоваться переменной по назначению — считывать и перезаписывать.</p>
            <h3>Инициализация переменной</h3>
            <p>Присвоение начального значения переменной называется <em>инициализацией</em> (англ. <em>initialization</em>). Это может происходить как при объявлении переменной, так и после:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int x = 4;
    int a, b, c, d;

    a = 1;
    b = 2;
    c = 3;
    d = 4;

    return 0;
}</code>
            <p>Если переменную не инициализировать и посмотреть, что она хранит, то увидим мы мусор (либо ноль), который остался в том участке памяти, который занимает сейчас наша переменная. Проверить это можно так:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int x;

    printf("%d\n", x);

    return 0;
}</code>
            <samp>1739292766</samp>
            <p>Этот факт может сыграть с невнимательным программистом злую шутку: этот мусор может оказаться весьма похожим на ожидаемый результат каких-либо вычислений, но не имеющий к ним никакого отношения. Так что, всегда инициализируйте переменные, прежде чем пользоваться ими!</p>
        </section>
        <section>
            <h2 id="data_types">Типы данных</h2>
            <p>Ранее в статье мелькало такое словосочетание как «тип данных», что же это такое? Как всегда, сложно о простом пишет Википедия:</p>
            <blockquote cite="http://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">
                <dfn>Тип данных</dfn> — фундаментальное понятие теории программирования. Тип данных определяет множество значений, набор операций, которые можно применять к таким значениям, и, возможно, способ реализации хранения значений и выполнения операций. Любые данные, которыми оперируют программы, относятся к определённым типам.
            </blockquote>
            <p>Проще говоря, тип данных — это некое «указание» компилятору о том, как данные представить, как их сохранить и что с ними можно делать.</p>
            <p>Типы данных языка можно разделить на две группы:</p>
            <ul>
                <li><em>Примитивный тип</em> (англ. <em>primitive data type</em>) — тип данных, предоставляемый языком программирования как базовая встроенная единица языка. Также этот тип данных называют ещё встроенным или базовым.</li>
                <li><em>Составной тип</em> (англ. <em>composite data type</em>) — это любой тип данных, который может быть создан в программе с помощью примитивных типов данных языка и других составных типов.</li>
            </ul>

            <p>Что даёт знание о типе данных переменной:</p>
            <ul>
                <li>представление о типе значения переменной и его диапазон (см. таблицу ниже);</li>
                <li>представление о размере памяти, выделяемой для переменной.</li>
            </ul>
            <h3>Таблица базовых типов в Си</h3>
            <figure>
                <table>
                    <tbody>
                    <tr>
                        <th>Типы данных</th>
                        <th>Описание</th>
                        <th>Размер</th>
                        <th>Диапазон значений </th>
                        
                    </tr>
                    <tr>
                        <td><code>char</code></td>
                        <td rowspan="2">целочисленный</td>
                        <td>1 байт (8 бит)</td>
                        <td>&minus;128..127</td>
                    </tr>
                        
                    <tr>
                        <td><code>int</code></td>
                        <td>4 байта (32 бита)</td>
                        <td>&minus;2147483648..2147483647</td>
                    </tr>

                    <tr>
                        <td><code>float</code></td>
                        <td rowspan="2">вещественный</td>
                        <td>4 байта (32 бита)</td>
                        <td>±3.4e±38</td>
                    </tr>
                    <tr>
                        <td><code>double</code></td>
                        <td>8 байт (64 бита)</td>
                        <td>±1.7e±308</td>
                    </tr>
                    </tbody>
                </table>
                <figcaption>Базовые типы данных Си</figcaption>
            </figure>
            <p>У этих типов данных также есть <em>модификаторы</em>, они влияют на размер типа данных и диапазон его значений.</p>
            <figure>
                <table>
                <thead>
                    <tr>
                        <th>Модификатор</th>
                        <th>Описание</th>
                        <th>Совместимость</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>signed</code></td> 
                        <td>преобразует значения к знаковым числам</td> 
                        <td><code>char</code> и <code>int</code>,<br>используется по умолчанию</td>
                    </tr> 
                    <tr> 
                        <td><code>unsigned</code></td> 
                        <td>преобразует значения к беззнаковым числам</td>
                        <td><code>char</code> и <code>int</code></td>
                    </tr>
                    <tr> 
                        <td><code>short</code></td> 
                        <td>уменьшает размер типа данных:<br>
                            <code>short int</code> — 2 байта (16 бит)</td> 
                        <td><code>int</code></td>
                    </tr>
                    <tr>
                        <td><code>long</code></td> 
                        <td>увеличивает размер типа данных:<br>
                            <code>long int</code> — 8 байт (64 бита)<br>
                            <code>long double</code> — 10 байт (80 бит)</td>
                        <td><code>int</code> и <code>double</code></td>
                    </tr>
                </tbody>
                </table>
                <figcaption>Модификаторы базовых типов в Си</figcaption>
            </figure>
        </section>
        <section>
            <h2 id="operators">Операторы</h2>
            <p>Немного терминологии: в английском языке есть термин <em>statement</em>, который означает наименьшую автономную часть языка программирования или команду (for statement, if statement, print statement), а также есть термин <em>operator</em>, который означает группу специальных функций для произведения арифметических, логических, строковых и прочих операций (logical operator, mathematical operator, string operator, binary operator). Оба эти термина переводят на русский как «оператор» — это неверно. Договоримся называть <em>оператором</em> только то, что подразумевает английский термин «operator», в свою очередь, «statement» — называть <em>конструкцией языка</em>.</p>
            <p>Итак, операторы принимают <em><a href="http://en.wikipedia.org/wiki/Operand" target="_blank">операнды</a></em> и возвращают результат. В зависимости от количества принимаемых операнд, операторы бывают:</p>
            <ul>
                <li>унарные — один операнд;</li>
                <li>бинарные — два операнда;</li>
                <li>тернарные — три операнда.</li>
            </ul>
            <p>В рамках языка Си можно выделить следующие группы операторов:</p>
           <ul>
                <li>Арифметические операторы</li>
                <li>Операторы сравнения</li>
                <li>Операторы присвоения</li>
                <li>Инкремент и декремент</li>
                <li>Логические операторы</li>
                <li>Битовые операторы</li>
            </ul>

            <h3>Арифметические операторы</h3>
            <p>Название говорит само за себя. Это операторы для произведения арифметических операций.</p>
            <figure>
                <table>
                <thead>
                    <tr>
                        <th>Оператор</th>
                        <th>Значение</th>
                        <th>Пример</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>+</code></td>
                        <td>сложение</td>
                        <td><code>2 + 2 = 4</code></td>
                    </tr>
                    <tr>
                        <td><code>&minus;</code></td>
                        <td>вычитание</td>
                        <td><code>2 &minus; 2 = 0</code></td>
                    </tr>
                    <tr>
                        <td><code>*</code></td>
                        <td>умножение</td>
                        <td><code>2 * 2 = 4</code></td>
                    </tr>
                    <tr>
                        <td><code>/</code></td>
                        <td>целочисленное деление</td>
                        <td><code>5 / 2 = 2</code></td>
                    </tr>
                    <tr>
                        <td><code>%</code></td>
                        <td>остаток от деления</td>
                        <td><code>5 % 2 = 1</code></td>
                    </tr>
                </tbody>
                </table>
                <figcaption>Арифметические операторы</figcaption>
            </figure>

            <h3>Операторы сравнения</h3>
            <p>Операторы сравнения возвращают 1 (истина) или 0 (ложь) в результате своей работы. Если утверждение верно, то вернёт 1, если нет — 0;</p>
            <figure>
                <table>
                <thead>
                    <tr>
                        <th>Оператор</th>
                        <th>Значение</th>
                        <th>Пример</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>&lt;</code></td>
                        <td>меньше</td>
                        <td><code>x &lt; y</code></td>
                    </tr>
                    <tr>
                        <td><code>&gt;</code></td>
                        <td>больше</td>
                        <td><code>x &gt; y</code></td>
                    </tr>
                    <tr>
                        <td><code>&lt;=</code></td>
                        <td>меньше или равно</td>
                        <td><code>x &lt;= y</code></td>
                    </tr>
                    <tr>
                        <td><code>&gt;=</code></td>
                        <td>больше или равно</td>
                        <td><code>x &gt;= y</code></td>
                    </tr>
                    <tr>
                        <td><code>==</code></td>
                        <td>равно</td>
                        <td><code>x == y</code></td>
                    </tr>
                    <tr>
                        <td><code>!=</code></td>
                        <td>не равно</td>
                        <td><code>x != y</code></td>
                    </tr>
                </tbody>
                </table>
                <figcaption>Операторы сравнения</figcaption>
            </figure>

            <h3>Операторы присвоения</h3>
            <p>Оказывается, можно не только присваивать, но и проводить арифметические операции и сразу присваивать их результат.</p>
            <figure>
                <table>
                <thead>
                    <tr>
                        <th>Оператор</th>
                        <th>Пример</th>
                        <th>Эквивалент</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>=</code></td>
                        <td><code>x = 5</code></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><code>+=</code></td>
                        <td><code>x += 15</code></td>
                        <td><code>x = x + 15</code></td>
                    </tr>
                    <tr>
                        <td><code>&minus;=</code></td>
                        <td><code>x &minus;= 4</code></td>
                        <td><code>x = x &minus; 4</code></td>
                    </tr>
                    <tr>
                        <td><code>*=</code></td>
                        <td><code>x *= 2</code></td>
                        <td><code>x = x * 2</code></td>
                    </tr>
                    <tr>
                        <td><code>/=</code></td>
                        <td><code>x /= 3</code></td>
                        <td><code>x = x / 3</code></td>
                    </tr>
                    <tr>
                        <td><code>%=</code></td>
                        <td><code>x %= 5</code></td>
                        <td><code>x = x % 5</code></td>
                    </tr>
                </tbody>
                </table>
                <figcaption>Операторы присвоения</figcaption>
            </figure>

            <h3>Инкремент и декремент</h3>
            <p>Эти операторы увеличивают либо уменьшают значение на единицу.</p>
            <figure>
                <table>
                <thead>
                    <tr>
                        <th>Оператор</th>
                        <th>Пример</th>
                        <th>Эквивалент</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>++</code></td>
                        <td><code>x++</code></td>
                        <td><code>x += 1</code></td>
                    </tr>
                    <tr>
                        <td><code>&minus;&minus;</code></td>
                        <td><code>x&minus;&minus;</code></td>
                        <td><code>x &minus;= 1</code></td>
                    </tr>
                </tbody>
                </table>
                <figcaption>Инкремент и декремент</figcaption>
            </figure>

            <h3>Логические операторы</h3>
            <p>Применяются к логическим значениям, то есть работают со значениями «ноль» (false) или «не ноль» (true).</p>
            <figure>
                <table>
                <thead>
                    <tr>
                        <th>Оператор</th>
                        <th>Значение</th>
                        <th>Пример</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>!</code></td>
                        <td>«не» – отрицание</td>
                        <td><code>!0 = 1</code>, <code>!1 = 0</code>, <code>!42 = 0</code></td>
                    </tr>
                    <tr>
                        <td><code>&amp;&amp;</code></td>
                        <td>«и» – <a href="http://en.wikipedia.org/wiki/Logical_conjunction" target="_blank">конъюнкция</a></td>
                        <td><code>0 &amp;&amp; 1 = 0</code></td>
                    </tr>
                    <tr>
                        <td><code>||</code></td>
                        <td>«или» — <a href="http://en.wikipedia.org/wiki/Logical_disjunction" target="_blank">дизъюнкция</a></td>
                        <td><code>0 || 1 = 1</code></td>
                    </tr>
                </tbody>
                </table>
                <figcaption>Логические операторы</figcaption>
            </figure>

            <h3>Битовые операторы</h3>
            <p>Эта группа операторов работает с битовым представлением числа. Применить их можно и к десятичному числу, но чтобы понять что произошло в результате, нужно представить число в двоичном виде.</p>
            <figure>
                <table>
                <thead>
                    <tr>
                        <th>Оператор</th>
                        <th>Значение</th>
                        <th>Описание</th>
                        <th>Пример</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>&lt;&lt;</code></td>
                        <td>сдвиг влево</td>
                        <td>Смещение всех битов числа влево на значение второго операнда.</td>
                        <td><code>0001 &lt;&lt; 1 = 0010</code></td>
                    </tr>
                    <tr>
                        <td><code>&gt;&gt;</code></td>
                        <td>сдвиг вправо</td>
                        <td>Смещение всех битов числа вправо на значение второго операнда.</td>
                        <td><code>0100 &gt;&gt; 2 = 0001</code></td>
                    </tr>
                    <tr>
                        <td><code>~</code></td>
                        <td>отрицание</td>
                        <td>Унарный оператор. На той позиции, где в двоичном представлении операнда был 0, в результате будет 1, и, наоборот, где была 1, там будет 0. Меняет знак числа.</td>
                        <td><code>~1001 = 0110</code></td>
                    </tr>
                    <tr>
                        <td><code>&amp;</code></td>
                        <td>побитовое «и»</td>
                        <td>Если оба соответствующих бита операндов равны 1, результирующий двоичный разряд равен 1; если же хотя бы один бит из пары равен 0, результирующий двоичный разряд равен 0. Эквивалентно применению логического «и» к каждой паре битов.</td>
                        <td><code>1001 &amp; 1010 = 1000</code></td>
                    </tr>
                    <tr>
                        <td><code>|</code></td>
                        <td>побитовое «или»</td>
                        <td>Если оба соответствующих бита операндов равны 0, двоичный разряд результата равен 0; если же хотя бы один бит из пары равен 1, двоичный разряд результата равен 1. Эквивалентно применению логического «или» к каждой паре битов.</td>
                        <td><code>1001 | 1010 = 1011</code></td>
                    </tr>
                    <tr>
                        <td><code>^</code></td>
                        <td>исключающее «или»</td>
                        <td>Если число складываемых единичных битов нечётно — результат равен 1, если же их число чётно, то результат равен 0.</td>
                        <td><code>1001 ^ 1010 = 0011</code></td>
                    </tr>
                </tbody>
                </table>
                <figcaption>Битовые операторы</figcaption>
            </figure>
            <p>Для просветления может быть полезна <a href="http://en.wikipedia.org/wiki/Truth_function#Table_of_binary_truth_functions" target="_blank">таблица истинности побитовых операторов</a> на Википедии.</p>
        </section>

        <footer>
            <address>
                Автор Gara.
            </address>
            <time datetime="2014-03-23">23.03.2014</time>
        </footer>
    </article>
    <script type="text/javascript" src="https://dl.dropboxusercontent.com/u/31437201/code.js"></script>
</body>
</html>
