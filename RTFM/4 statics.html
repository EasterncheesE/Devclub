
<!DOCTYPE html>
<!--[if IE 7]>
<html lang="ru" class="ie7">
<![endif]-->
<!--[if IE 8]>
<html lang="ru" class="ie8">
<![endif]-->
<!--[if (lt IE 7)|(gt IE 8)]><!-->
<html lang="ru">
<!--<![endif]-->
<head>
    <title>Статические свойства и методы.</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://dl.dropboxusercontent.com/u/31437201/article.css">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
    <article class="page">
        <h1>Статические свойства и методы</h1>
        <aside class="plan">
            <div class="contents">
                <h2>План</h2>
                <ol>
                    <li><a href="#statics">Cтатика</a>
                        <ol>
                            <li><a href="#file">Файл</a></li>
                            <li><a href="#function">Функция</a></li>
                            <li><a href="#class">Класс</a></li>
                        </ol>
                    </li>
                    <li><a href="#static_members">Статические свойства и методы</a></li>
                    <li><a href="#copy_constructor">Конструктор копирования</a></li>
                    <li><a href="#assignment_operator">Оператор присваивания</a></li>
                    <li><a href="#rule_of_three">Правило «тройки»</a></li>
                </ol>
            </div>
        </aside>

        <section>
            <h2 id="statics">Cтатика</h2>
            <p>
                Ключевое слово <code>static</code> в языке C++ является довольно интересным, ибо означает разные вещи, в зависимости от применения. Рассморим три варианта.
            </p>
            <h3 id="file">Файл</h3>
            <p>
                Как известно, локальные переменные доступны в пределах блока, в котором они объявлены, а также во всех вложенных блоках. Глобальные переменные доступны во всей программе. Локальные переменные объявляются внутри блока, глобальные — за пределами блоков.
            </p>
            <p>
                Использование ключевого слова <code>static</code> при объявлении глобальной переменной ограничивает область видимости этой переменной файлом. Другими словами, статическая переменная уровня файла видна только внутри файла.
            </p>
            <code data-lang="c">static int fileScopeInt; // переменная уровня файла
float globalScopeFloat;  // глобальная переменная

int main() {
    double localScopeDouble; // локальная переменная
}</code>

            <h3 id="function">Функция</h3>
            <p>
                По умолчанию, локальные переменные обладают «автоматической продолжительностью жизни» (англ. automatic duration). Это означает, что они уничтожаются, когда выполнение кода покидает область видимости, в которой эти переменные объявлены. Такое поведение можно указать явно с помощью ключевого слова <code>auto</code>, но на практике этим не пользуются.
            </p>
            <p>
                Добавление ключевого слова <code>static</code> при объявлении локальной переменной изменяет это поведение, и переменная переходит к «фиксированной продолжительности жизни» (англ. fixed duration). Такие переменные по прежнему доступны только внутри блока, в котором они объявлены, но инициализируются один раз и не удаляются при выходе из области видимости. Таким образом можно, например, посчитать количество вызовов функции:
            </p>
            <code data-lang="c">void someFunction() {
    static int count = 1;

    printf("function called %d times\n", count);

    count += 1;
}</code>

            <h3 id="class">Класс</h3>
            <p>
                Статическими в классе могут быть как атрибуты, так и методы. Область видимости статических членов уровня класса ограничена классом, в котором они объявлены. Для всех экземпляров класса создаётся всего одна копия статического члена, который, при этом, не является частью объекта. Статические члены класса объявляются с использованием ключевого слова <code>static</code>.
            </p>
            <p>
                Типичное применение статический членов класса — хранение и обработка данных, относящихся ко всем экземплярам класса, а не к какому-то конкретному. Например, это может быть счетчик, который подсчитывает общее количество созданных экземляров класса. Каждый раз при создании нового объекта нужно попросту инкрементировать этот счетчик.
            </p>
            <p>
                Так как статические члены класса не относятся к какому-либо конкретному объекту — обращаться к ним нужно используя имя класса:
            </p>
            <code data-lang="c">class X {
    static int staticVariable; // статический атрибут класса

    static void doBook(); // статический метод
}

int main() {
    // обращение к статическим членам через имя класса
    X::staticVariable;
    X::doBook();
}</code>
        </section>

        <section>
            <h2 id="static_members">Статические свойства и методы</h2>
            <p>
                Статические атрибуты и методы не относятся к конкретным объектам. Они относятся ко всему классу.
                Поэтому после объявления статического члена класса, он существует, даже если отсутствуют экземпляры класса.
                Важной особенностью является то, что объявление статического члена при объявлении класса всего лишь указывает, что в классе есть этот член. Инициализировать статический атрибут или реализовывать статический метод необходимо за пределами объявления класса в области видимости его пространства имен:
            </p>
            <code data-lang="c">class Book {
    private:
        static int totalCount;      // объявление стсатического атрибута

    public:
        static int getTotalCount(); // объявление статического метода
};

int Book::totalCount = 0;    // инициализация статического атрибута

int Book::getTotalCount() {    // реализация статического метода
    return totalCount;
}</code>
        <p>
            Как видите, при реализации статического метода можно пользоваться статическими атрибутами и другими статическими методами этого же класса напрямую, без указания пространства имён.
        </p>
        <p>
            Статические атрибуты можно инициализировать другими статическими членами:
        </p>
<code data-lang="c">class Book {
    private:
        static int totalCount;

    public:
        static int getTotalCount();
        static int getInitValue();
};

int Book::getInitValue() {
    return 0;
}

int Book::getTotalCount() {
    return totalCount;
}

int Book::totalCount = Book::getInitValue();</code>
        <p>
            Статический метод не может быть константным:
        </p>
        <code data-lang="c">class Book {
    static int someMethod() const; // ошибка компиляции
};</code>
        <p>
            Константность метода указывает на то, что метод не может изменять состояние объекта. Но ведь статический метод не относится к конкретному объекту. Поэтому он не может быть константным. По этой же причине в статическом методе нет указателя <code>this</code>.
        </p>
        <code data-lang="c">class Book {
    static int someMethod();
};

int Book::someMethod() {
    this->doSomething();    // ошибка компиляции из-за отсутствия this
}</code>
        <p>
            При попытке использовать <code>this</code> внутри статического метода получим ошибку компиляции:
        </p>
        <pre>error: invalid use of 'this' outside of a non-static member function</pre>
        <p>
            Статический атрибут класса вполне может быть константой, но при этом инициализировать его нужно как константу, например так:
        </p>
        <code data-lang="c">class Book {
    static const int classConstant;
};

const int Book::classConstant = 42;</code>
        <p>
            А лучше так:
        </p>
        <code data-lang="c">class Book {
    static const int classConstant = 42;
};</code>
        <p>
            Несмотря на то, что статический метод не относится к объектам, нельзя в одном классе объявить два одноимённых метода с одинаковыми аргументами, даже если один из этих методов статический. Этот ньюанс становится очевидным при разнесении класса на заголовок и реализацию.
        </p>
        </section>

        <section>
            <h2 id="copy_constructor">Конструктор копирования</h2>
            <blockquote>
                Конструктором копирования (в англоязычной литературе используется термин <i>copy constructor</i>) называется специальный конструктор в языке программирования C++, применяемый для создания нового объекта как копии уже существующего. Такой конструктор принимает как минимум один аргумент: ссылку на копируемый объект.
            </blockquote>
            <p>
                Копирование объектов в С++ осуществляется засчет конструктора копирования и оператора присваивания, о котором речь пойдет позже.
            </p>
            <p>
                Конструктор копирования первым аргументом принимает ссылку на объект собственного класса, причём константную:
            </p>
            <code data-lang="c">class Book {
    Book(const Book&amp; copy);
};</code>
            <p>
                Почему именно ссылку? Потому что если передать объект в функцию по значению — это приведет к неявному копированию объекта. Этим же конструктором. Затем ещё раз. И ещё... В итоге мы заглохнем в глубокой рекурсии.
            </p>
            <code data-lang="c">class Book {
    Book(const Book copy); // неправильно — приведет к глубокой рекурсии
};</code>
            <p>
                Конструктор копирования вызывается в четырёх случаях:
            </p>
            <p>
                1. Когда объект является возвращаемым значением функции:
            </p>
            <code data-lang="c">Book getBook {
    return Book(); // при возврате значения произойдет копирование
};</code>
            <p>
                2. Когда объект передается функции по значению в качестве аргумента:
            </p>
            <code data-lang="c">void print(Book book) { // при передаче по значению произойдет копирование
    std::cout &lt;&lt; book &lt;&lt; std::endl;
};</code>
            <p>
                3. Когда объект конструируется на основе другого объекта (того же класса):
            </p>
            <code data-lang="c">int main() {
    Book book1 = Book();
    Book book2 = Book(book1);   // явный вызов конструктора копирования
    Book book3 = book2;         // неявный вызов конструктора копирования

    return 0;
};</code>
            <p>
                4. Когда компилятор генерирует временный объект (как в первом и втором случаях выше; как явное преобразование и т.д.)
            </p>
            <h3 id="copy_and_statics">Копирование объектов и статика</h3>
            <p>
                Допустим, у нас есть класс <code>Book</code>, в котором есть статический счетчик книг. У каждой книги есть название и уникальный идентификатор:
            </p>
            <code data-lang="c">#include &lt;iostream&gt;

class Book {
    private:
        int id;
        std::string title;
    public:
        static int totalBooks;
        static int lastId;

    public:
        Book(const std::string&amp; title) {
            totalBooks += 1;
            lastId += 1;
            this-&gt;id = lastId;
            this-&gt;title = title;
        }

        ~Book() {
            totalBooks -= 1;
        }

        int getId() const {
            return this-&gt;id;
        }

        const std::string&amp; getTitle() const {
            return this-&gt;title;
        }
};

int Book::totalBooks = 0;
int Book::lastId     = 0;


int main() {
    Book *book1 = new Book("Gulliver");
    Book *book2 = new Book("Predator");
    Book *book3 = new Book("Lord of the Rings");

    std::cout &lt;&lt; "book1 id: " &lt;&lt; book1-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book1-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 1
    std::cout &lt;&lt; "book2 id: " &lt;&lt; book2-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book2-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 2
    std::cout &lt;&lt; "book3 id: " &lt;&lt; book3-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book3-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 3

    std::cout &lt;&lt; "totalBooks: " &lt;&lt; Book::totalBooks &lt;&lt; std::endl; // totalBooks: 3

    delete book1;
    delete book3;

    std::cout &lt;&lt; "totalBooks: " &lt;&lt; Book::totalBooks &lt;&lt; std::endl; // totalBooks: 1

    delete book2;

    std::cout &lt;&lt; "totalBooks: " &lt;&lt; Book::totalBooks &lt;&lt; std::endl; // totalBooks: 0

    book1 = new Book("Bible");

    std::cout &lt;&lt; "book1 id: " &lt;&lt; book1-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book1-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 1
    std::cout &lt;&lt; "totalBooks: " &lt;&lt; Book::totalBooks &lt;&lt; std::endl; // totalBooks: 1

    return 0;
}</code>
        <p>
            Статический счетчик увеличивается на 1 каждый раз, когда создается новый объект, и уменьшается на 1 при уничтожении объекта. Каждый объект получает уникальный идентификатор при создании и увеличивает на 1 счетчик идентификаторов. Вроде понятно.
        </p>
        <p>
            А теперь давайте сделаем копию книги:
        </p>
        <code data-lang="c">#include &lt;iostream&gt;

class Book {
    private:
        int id;
        std::string title;
    public:
        static int totalBooks;
        static int lastId;

    public:
        Book(const std::string&amp; title) {
            totalBooks += 1;
            lastId     += 1;
            this-&gt;id    = lastId;
            this-&gt;title = title;
        }

        ~Book() {
            totalBooks -= 1;
        }

        int getId() const {
            return this-&gt;id;
        }

        const std::string&amp; getTitle() const {
            return this-&gt;title;
        }
};

int Book::totalBooks = 0;
int Book::lastId     = 0;


int main() {
    Book *book1 = new Book("Gulliver");
    Book *book2 = new Book(*book1);

    std::cout &lt;&lt; "book1 id: " &lt;&lt; book1-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book1-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 1
    std::cout &lt;&lt; "book2 id: " &lt;&lt; book2-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book2-&gt;getTitle() &lt;&lt; std::endl;    // book2 id = 1
    std::cout &lt;&lt; "totalBooks: " &lt;&lt; Book::totalBooks &lt;&lt; std::endl; // totalBooks: 1

    delete book1;
    delete book2;

    return 0;
}</code>
        <p>
            В результате копирования получаем два объекта с одинаковым идентификатором, а счетчик объектов по-прежнему показывает, что у нас всего один объект. По логике вещей, счетчик объектов должен увеличиться, ведь мы создали еще один объект. Да и идентификатор объекта должен быть уникальным.
        </p>
        <p>
            Исправить сложившуюся ситуацию поможет конструктор копирования. Давайте внесём изменения:
        </p>
        <code data-lang="c">#include &lt;iostream&gt;

class Book {
    private:
        int id;
        std::string title;
    public:
        static int totalBooks;
        static int lastId;

    public:
        Book(const std::string&amp; title) {
            totalBooks += 1;
            lastId     += 1;
            this-&gt;id    = lastId;
            this-&gt;title = title;
        }

        // добавим конструктор копирования
        Book(const Book&amp; copy) {
            totalBooks += 1;          // увеличиваем счетчик объектов
            lastId     += 1;          // увеличиваем счетчик идентификаторов
            this-&gt;id    = lastId;     // присваиваем копии уникальный идентификатор
            this-&gt;title = copy.title; // копируем остальные поля
        }

        ~Book() {
            totalBooks -= 1;
        }

        int getId() const {
            return this-&gt;id;
        }

        const std::string&amp; getTitle() const {
            return this-&gt;title;
        }
};

int Book::totalBooks = 0;
int Book::lastId     = 0;


int main() {
    Book *book1 = new Book("Gulliver");
    Book *book2 = new Book(*book1);

    std::cout &lt;&lt; "book1 id: " &lt;&lt; book1-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book1-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 1
    std::cout &lt;&lt; "book2 id: " &lt;&lt; book2-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book2-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 2
    std::cout &lt;&lt; "totalBooks: " &lt;&lt; Book::totalBooks &lt;&lt; std::endl; // totalBooks: 3

    delete book1;
    delete book2;

    return 0;
}</code>
        <p>
            Теперь копирование работает правильно, так как мы и хотели. При копировании увеличиватся количество объектов, и каждый объект обладает уникальным идентификатором, даже если объект является копией.
        </p>
        </section>

        <section>
            <h2 id="assignment_operator">Оператор присваивания</h2>
            <p>
                Ещё одним способом копирования объектов является оператор присваивания:
            </p>
            <code data-lang="c">int main() {
    Book book1 = Book();
    Book book2 = Book(book1);   // явный вызов конструктора копирования
    Book book3 = book2;         // неявный вызов конструктора копирования
    Book book4;

    book4 = book3;              // вызов оператора присваивания (operator=)

    return 0;
};</code>
            <p>
                Ситуация с оператором присваивания обстоит так же, как и в случае с конструктором копирования. Если мы самостоятельно не определяем оператор присваивания, который используется для присваивания объектов одного класса друг другу — компилятор автоматически его генерирует. Для класса <code>Book</code> он выглядит вот так:
            </p>
            <code data-lang="c">Book&amp; operator=(const Book&amp; copy) {
    this-&gt;id    = copy.id;
    this-&gt;title = copy.title;

    return *this;
}</code>
            <p>
                Сгенерированный оператор присваивания выполняет простое присваивание значений каждого из атрибутов одного объекта атрибутам другого. Как и в случае с конструктором копирования, изменения не затрачивают статические свойства.
            </p>
            <p>
                Поэтому, при работе со статикой, нужно переопределять не только конструктор копирования, но и оператор присваивания. Добавим немного кодца в класс <code>Book</code>:
            </p>
            <code data-lang="c">#include &lt;iostream&gt;

class Book {
    private:
        int id;
        std::string title;
    public:
        static int totalBooks;
        static int lastId;

    public:
        Book(const std::string&amp; title) {
            totalBooks += 1;
            lastId     += 1;
            this-&gt;id    = lastId;
            this-&gt;title = title;
        }

        // конструктор копирования
        Book(const Book&amp; copy) {
            totalBooks += 1;
            lastId     += 1;
            this-&gt;id    = lastId;
            this-&gt;title = copy.title;
        }

        // оператор присваивания
        Book&amp; operator=(const Book&amp; copy) {
            this-&gt;title = copy.title; // копируем остальные поля

            return *this;
        }

        ~Book() {
            totalBooks -= 1;
        }

        int getId() const {
            return this-&gt;id;
        }

        const std::string&amp; getTitle() const {
            return this-&gt;title;
        }
};

int Book::totalBooks = 0;
int Book::lastId     = 0;


int main() {
    Book *book1 = new Book("Gulliver");
    Book *book2 = new Book(*book1);

    std::cout &lt;&lt; "book1 id: " &lt;&lt; book1-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book1-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 1
    std::cout &lt;&lt; "book2 id: " &lt;&lt; book2-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book2-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 2
    std::cout &lt;&lt; "totalBooks: " &lt;&lt; Book::totalBooks &lt;&lt; std::endl; // totalBooks: 3

    *book1 = *book2;

    std::cout &lt;&lt; "book1 id: " &lt;&lt; book1-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book1-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 1
    std::cout &lt;&lt; "book2 id: " &lt;&lt; book2-&gt;getId() &lt;&lt; ", title: " &lt;&lt; book2-&gt;getTitle() &lt;&lt; std::endl;    // book1 id = 2
    std::cout &lt;&lt; "totalBooks: " &lt;&lt; Book::totalBooks &lt;&lt; std::endl; // totalBooks: 3


    delete book1;
    delete book2;

    return 0;
}</code>
        <p>
            При использовании оператора присваивания для копирования, мы используем два готовых объекта. Мы не создаём новые объекты. Поэтому изменять значение глобального счетчика объектов не нужно. По этой же причине не нужно изменять идентификаторы созданных объектов. В нашем случае, при присваивании необходимо просто скопировать нужные поля (title).
        </p>
        </section>

        <section>
            <h2 id="rule_of_three">Правило «тройки»</h2>
            <p>
                 Практика показывает, что в случаях, когда необходимо переопределить один из следующих методов:
            </p>
            <ol>
                <li>Деструктор</li>
                <li>Конструктор копирования</li>
                <li>Оператор присваивания копированием</li>
            </ol>
            <p>
                необходимо переопределять все три метода.
            </p>
            <p>
                Эти три метода автоматически генерируются компилятором. И есть подозрение, что если функционал одного из них вас не устраивает — не устраивает и поведение двух других.
            </p>

            <p>
                Если вы не хотите выгребать непонятные баги в вашем чудесном программном обеспечении — следуйте этому простому правилу. Чуть более подробно об этом <a href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D1%82%D1%80%D1%91%D1%85_(C%2B%2B_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">на википедии</a>.
            </p>


        </section>

        <footer>
            <address>
                Автор X-Treem.
            </address>
            <time datetime="2013-12-13">13.12.2013</time>
        </footer>
    </article>
    <script type="text/javascript" src="https://dl.dropboxusercontent.com/u/31437201/code.js"></script>
</body>
</html>
