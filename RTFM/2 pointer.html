<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Указатели. Адресная арифметика</title>
    <link rel="stylesheet" href="https://dl.dropboxusercontent.com/u/31437201/article.css">
</head>
<body>
    <article class="page">
        <h1>Указатели. Адресная арифметика</h1>
        <aside class="plan">
            <div class="contents">
                <h2>План</h2>
                <ol>
                    <li><a href="#pointer">Указатель</a></li>
                    <ol>
                        <li><a href="#address_of">Оператор взятия адреса</a></li>
                        <li><a href="#address_assignment">Присваивание адреса</a></li>
                        <li><a href="#dereferencing">Разыменование указателя</a></li>
                        <li><a href="#size_of_pointer">Размерность указателя</a></li>
                        <li><a href="#pointer_usage">Использование указателя</a></li>
                    </ol>
                    <li><a href="#pointer_arithmetic">Адресная арифметика</a></li>
                    <ol>
                        <li><a href="#address_limit">Есть ли предел?</a></li>
                        <li><a href="#perversion">Другие арифметические операции над указателями</a></li>
                    </ol>
                </ol>
            </div>
            <div class="links">
            </div>
        </aside>

        <section>
            <h2 id="pointer">Указатель</h2>
            <p>Чтобы узнать, что такое указатель в программировании, обратимся к Википедии:</p>
            <blockquote cite="http://ru.wikipedia.org/wiki/%D0%A3%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)"><dfn>Указатель</dfn> (англ. pointer) — переменная, диапазон значений которой состоит из адресов ячеек памяти или специального значения — нулевого адреса. Последнее используется для указания того, что в данный момент там ничего не записано.</blockquote>
            <p>Итак, выяснилось, что указатель — это переменная, которая содержит в себе адрес ячейки памяти. Теперь нужно кое-что понять об устройстве памяти.</p>
            <p>Организация памяти компьютера по своему принципу схожа на организацию самой обычной улицы, на которой размещены самые обычные дома, имеющие самые обычные таблички с номером, с небольшим отличием — дома на этой улице стоят только по одной стороне. Память компьютера также выстроена линейно. То есть, состоит из ячеек которые идут друг за другом и каждая ячейка имеет свой адрес.</p>
            <p>А теперь представьте знак, на котором написан адрес одного из домов — это типичный указатель, помогающий найти нужный дом. Такая же ситуация и с указателями в программировании — адрес ячейки памяти можно сохранить в специальную переменную. Такая переменная и называется <em>указателем</em>.</p>

            <h3 id="address_of">Оператор взятия адреса</h3>
            <p>Для начала выясним, как добыть адрес ячейки памяти. Для этого существует специальный унарный оператор — <code>&amp;</code> (амперсанд), операндом которого выступает переменная, адрес которой нужно получить — <code>&amp;&lt;переменная&gt;</code>. Его работу можно продемонстрировать на простом примере:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int x = 42;

    printf("Address of x: %p\n", &amp;x);
    // для вывода адреса используется специальный шаблон — %p
    
    printf("Value of x: %d\n", x);

    return 0;
}</code>
            <p>Результат работы этого кода будет примерно следующим:</p>
            <samp>Address of x: 0x7fff53ca9c58
Value of x: 42</samp>
            <p>Внимательный читатель уже заметил, что оператор взятия адреса уже мелькал раньше, в функции <code>scanf()</code>. Использование <code>&amp;</code> в <code>scanf()</code> стало более осмысленным: функция записывает полученное из консоли значение в ячейку памяти, адрес которой получаем при использовании <code>&amp;</code>.</p>

            <h3 id="address_assignment">Присваивание адреса</h3>
            <p>Раз уж мы научились получать адрес, было бы неплохо иметь возможность его хранить. Для этого нам и нужны указатели:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int x = 42;
    // объявляем и инициализируем указатель:
    int *pointer = &amp;x;

    printf("Address of x: %p\n", &amp;x);
    printf("Value of pointer: %p\n", pointer);

    return 0;
}</code>
            <samp>Address of x: 0x7fff53ca9c58
Value of pointer: 0x7fff53ca9c58</samp>
            <p>Визуально инициализация указателя отличается от инициализации любой другой переменной наличием <code>*</code> (звёздочка, астериск). Хоть звёздочка и стоит ближе к названию переменной, но свидетельствует она о типе данных. Она нам как бы намекает на то, что это указатель на <code>int</code>, а не целочисленный тип данных <code>int</code>.</p>
            <p>В форме записи <code>int *</code> звёздочка говорит о том, что это именно указатель, а <code>int</code> говорит о типе переменной, адрес которой хранит указатель.</p>
            <p>Предыдущий пример схематически можно изобразить так:</p>
            <figure>
                <table>
                    <tbody>
                         <tr>
                            <th>Адрес ячейки</th>
                            <th>Значение</th>
                            <th>Переменная</th>
                        </tr>
                        <tr>
                            <td><code>0x7fff53ca9c48</code></td>
                            <td>…</td>
                            <td><code>…</code></td>
                        </tr>
                        <tr>
                            <td><code>0x7fff53ca9c50</code></td>
                            <td>0x7fff53ca9c58</td>
                            <td><code>pointer</code></td>
                        </tr>
                        <tr>
                            <td><code>0x7fff53ca9c58</code></td>
                            <td>42</td>
                            <td><code>x</code></td>
                        </tr>
                        <tr>
                            <td><code>0x7fff53ca9c60</code></td>
                            <td>…</td>
                            <td><code>…</code></td>
                        </tr>
                    </tbody>
                </table>
            </figure>

            <h3 id="dereferencing">Разыменование указателя</h3>
            <p>Заголовок звучит страшно. Разберёмся, что скрывается за этими словами. Иметь адрес какой-то переменной — это очень круто, но что с этим делать? Видимо, если есть возможность взять адрес переменной, значит должна быть возможность достать значение по этому адресу. Операция обращения к значению в памяти, на которое указывает указатель, называется <em>разыменование</em> (англ. <em>dereferencing</em>). Соответственно, существует оператор разыменования — <code>*</code>, да-да, всё та же звёздочка, только для другой цели. Рассмотрим пример:</p>
             <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int x = 42;
    int *pointer = &amp;x;     // тут * — для объявления указателя
    
    *pointer += 1;         // тут * — для разыменования указателя
    printf("%d\n", x * 5); // а тут — для умножения

    return 0;
}</code>
            <p>Обратите внимание на седьмую строку: с помощью оператора разыменования мы обратились к значению, адрес которого хранит <code>pointer</code>, то есть, фактически к значению переменной <code>x</code>, и увеличили это значение на единицу. Ровно то же самое произойдёт, если сделать <code>x += 1</code>.</p>


            <h3 id="size_of_pointer">Размерность указателя</h3>
            <p>Тип данных «указатель» (в общем случае — <code>void *</code>), в зависимости от разрядности ОС, может иметь разный размер. Чтобы выяснить размер указателя в конкретном случае, достаточно провести маленький эксперимент, воспользовавшись функцией <code>sizeof()</code>:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int *pointer;

    printf("Size of pointer: %lu\n", sizeof(pointer));

    return 0;
}</code>
            <samp>Size of pointer: 8</samp>
            <p>Вспомним аналогию с домами и указателями-знаками. По сути, от того, на какой дом указывает знак — на небоскрёб на 140 этажей или на сарай, на его собственном размере это никак не сказывается, ведь для того, чтобы написать номер дома, много места не нужно. Та же история в программировании: размер указателя не зависит от того, указывает ли он на переменную типа <code>int</code> в 4 байта или на последовательность полезных данных в 2 Гбайта. В этом и заключается основной смысл применения указателя.</p>

            <h3 id="pointer_usage">Использование указателя</h3>
            <p>Наконец-то мы пришли к главному вопросу — что делать с указателями?</p>
            <p>Небольшое лирическое отступление: представьте себе ситуацию, когда поломались часы и нужно отнести их в ремонт, обычно никого не затруднит найти ближайший ларёк по ремонту часов и принести их туда. Другая ситуация — нужно провести ремонт в квартире, врядли кто-то возьмёт квартиру и понесёт в ларёк по ремонту квартир. Скорее всего, нужно пригласить ремонтную бригаду по адресу квартиры. Улавливаете?</p>
            <p>Наиболее показательный пример полезности указателей можно показать на функциях. Итак, пример:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int increment(int value) {
    return value += 1;
}

int main() {
    int x = 42;

    increment(x);
    printf("%d\n", x);

    return 0;
}</code>
            <samp>42</samp>
            <p>Почему значение <code>x</code> не поменялось? Ответ очевиден: потому что мы не присвоили результат работы функции <code>increment()</code> переменной <code>x</code>. Рассмотрим более детально, что тут произошло: в десятой строке мы передали значение переменной <code>x</code> в функцию, функция сохранила это значение в свою уютненькую переменную <code>value</code>, то есть произошло <em>копирование значения</em> в функцию. Что произошло дальше и так понятно.</p>
            <p>Ключевой момент — копирование значения. Очень часто размер принимаемого значения может быть очень большим, например то же видео, и копировать его каждый раз, когда он нужен — очень затратное занятие. Это как тянуть квартиру в ларёк по ремонту квартир.</p>
            <p>Тот же пример, но с использованием указателя:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

void increment(int *x) {
    *x += 1;
}

int main() {
    int x = 42;

    increment(&amp;x);
    printf("%d\n", x);

    return 0;
}</code>
            <samp>43</samp>
            <p>Вот теперь всё в порядке! Мы передали в функцию адрес переменной <code>x</code> (строка 10), функция приняла этот адрес (обратите внимание, что тип аргумента — <code>int *</code>) и сохранила в <i>локальную</i> переменную <code>x</code>. Для того, чтобы работать со значением, которое хранится по этому адресу, нужно разыменовать указатель, что успешно было сделано. То есть, в этот раз мы работали не с копией значения, а с оригиналом — с тем самым <code>x</code>, который в восьмой строке.</p>
            <p>По правде говоря, в данном конкретном примере мы ничего не выиграли, потому что размер указателя — 8 байт, а размер <code>int</code> — 4 байт. То есть, даже проиграли в разрезе экономии памяти. Поэтому важно применять указатели именно там, где они действительно нужны.</p>
        </section>
        <section>
            <h2 id="pointer_arithmetic">Адресная арифметика</h2>
            <p>А вы уже задумались о том, а что будет, если обратиться к какому-то совсем другому адресу, другой программы? Так сказать, полюбопытствовать, что же хранится в других адресах? По нашей аналогии, это как заглянуть в чужой дом — любопытно, но наказуемо.</p>
            <p>Милиции на компьютере нет, поэтому давайте экспериментировать!</p>
            <p>Прежде чем лезть в другую программу, проверим как все работает на своей. Если адреса — это числа, значит, с ними можно производить арифметические операции! Пробуем:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int *p;
    int x = 10;
    int y = 20;
    int z = 30;

    printf("Address of x: %p\n", &amp;x);
    printf("Address of y: %p\n", &amp;y);
    printf("Address of z: %p\n", &amp;z);
    
    p = &amp;x;
    printf("p: %p\n", p);
    
    p -= 1;
    printf("p: %p\n", p);

    p -= 1;
    printf("p: %p\n", p);

    return 0;
}</code>
            <samp>Address of x: 0x7fff51129c4c
Address of y: 0x7fff51129c48
Address of z: 0x7fff51129c44
p: 0x7fff51129c4c
p: 0x7fff51129c48
p: 0x7fff51129c44</samp>
            <p>По аналогии с домами: зная номер дома, можно прибавить к этому номеру число и получим другой номер дома. И с большой вероятностью, перейдя по этому новому адресу, обнаружим там дом, но другой.</p>
            <p>Зная адрес переменной <code>x</code>, отнимем от него единицу и получим новый адрес — адрес переменной <code>y</code>.</p>
            <p class="notabene">В данном конкретном примере, нужно именно отнять единицу, из-за особенности памяти, в которой хранятся переменные <code>x, y, z</code> и принципа распределения адресов памяти в конкретной ОС.</p>
            <p>Отнимая или прибавляя к значению указателя единицу, нужно понимать, что под ней скрывается размер типа переменной, в случае <code>int</code> — 4 байта. Именно поэтому, отняв «единицу» от <code>0x7fff51129c4c</code> получили адрес переменной <code>y</code>, то есть <code>0x7fff51129c48</code>, а не <code>0x7fff51129c4b</code>.</p>
            <p>Плюс один к номеру дома даст номер соседнего дома, но расстояние между ними отнюдь не один метр, а длина дома. Так же и тут.</p>
            <p>Попробуем что-то сделать со значениями по тем адресам, которые мы получаем в результате арифметических операций:</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int *p;
    int x = 10;
    int y = 20;
    int z = 30;

    p = &amp;x;

    p -= 1;
    *p -= 10;
    
    p -= 1;
    *p -= 20;

    printf("x: %d (%p)\n", x, &amp;x);
    printf("y: %d (%p)\n", y, &amp;y);
    printf("z: %d (%p)\n", z, &amp;z);

    return 0;
}</code>
            <samp>x: 10 (0x7fff57670c4c)
y: 10 (0x7fff57670c48)
z: 10 (0x7fff57670c44)</samp>
            
            <h3 id="address_limit">Есть ли предел?</h3>
            <p>А теперь отнимем не единицу, а что-то намного больше и посмотрим, куда нас закинет слепой случай!</p>
            <code data-lang="c">#include &lt;stdio.h&gt;

int main() {
    int *p;
    int x = 10;

    p = &amp;x;
    p -= 10000000;


    printf("p: %d (%p)\n", *p, p);

    return 0;
}</code>
            <samp>Segmentation fault: 11</samp>
            <p>Незрячий случай! Видать, кончилась наша уютная улица и вломились мы на территорию охраняемого стратегического объекта, куда нас не пустили.</p>
            <p>Оказывается, ОС хорошо следит за тем, кому и сколько памяти она выделила. Попытка обратиться к адресу памяти, доступ к которому нам не разрешён, приведёт к ошибке — <a href="http://en.wikipedia.org/wiki/Segmentation_fault" target="_blank">segmentation fault</a>.</p>
            <p>Снова вспомним функцию <code>scanf()</code>: если вы забываете поставить амперсанд перед переменной, то <code>scanf()</code> получает не адрес переменной, а её значение (допустим, оно равно 5). Соответственно, попытка записать что-либо в память по адресу 5, будет пресечена операционной системой, и вы увидите знакомую ошибку.</p>

            <h3 id="perversion">Другие арифметические операции над указателями</h3>
            <p>Что будет, если указатель умножить на указатель? Или разделить? Или возвести в степень? Видимо, ничего хорошего. Чтобы прояснить этот вопрос, попробуйте представить, что будет, если адрес «Верхний Вал, 58» умножить на три.</p>
        </section>

        <footer>
            <address>
                Автор Gara.
            </address>
            <time datetime="2014-03-19">19.03.2014</time>
        </footer>
    </article>
    <script type="text/javascript" src="https://dl.dropboxusercontent.com/u/31437201/code.js"></script>
</body>
</html>
