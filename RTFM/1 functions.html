<!DOCTYPE html>
<!--[if IE 7]>
<html lang="ru" class="ie7">
<![endif]-->
<!--[if IE 8]>
<html lang="ru" class="ie8">
<![endif]-->
<!--[if (lt IE 7)|(gt IE 8)]><!-->
<html lang="ru">
<!--<![endif]-->
<head>
    <title>Область видимости. Функции.</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://dl.dropboxusercontent.com/u/31437201/article.css">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
    <article class="page">
        <h1>Область видимости. Функции.</h1>
        <aside class="plan">
            <div class="contents">
                <h2>План</h2>
                <ol>
                    <li><a href="#visibility">Область видимости</a></li>
                    <li><a href="#function">Функции</a></li>
                </ol>
            </div>
        </aside>
        <section>
            <h2 id="visibility">Область видимости</h2>
            <p>
                Как сообщает Википедия: 
            </p>
            <blockquote>
                Область видимости (англ. scope) обозначает область программы, в пределах которой идентификатор (имя) некоторой переменной продолжает быть связанным с этой переменной и возвращать её значение. За пределами области видимости тот же самый идентификатор может быть связан с другой переменной, либо быть свободным (не связанным ни с какой из них).
            </blockquote>
            <p>
                По сути, это означает, что переменная, объявленная в конкретном блоке кода видна внутри этого блока кода и во всех вложенных. Переменная, которая объявлена во вложенном блоке кода, не видна во внешних блоках.
            <p>
            <p>
                Давайте, для понятности ситуации, разберемся с тем, что такое блоки кода. По сути, блок — это часть кода, которая сгруппирована и воспринимается как единое целое. По смыслу очень похоже на параграф в тексте. Для выделения блоков в программе используют специальные конструкции, которые в языке Си называются операторными скобками и записываются при помощи фигурных скобок <code>{}</code>. Код который заключен в такие скобки является блоком кода.
            </p>
            <code data-lang="c" data-file="scope.c">#include &lt;stdio.h&gt;

// глобальная область видимости

int main() { //начало блока функуции main()
    int x, y; // переменные, объявленные в блоке функции main()
    int max;

    scanf("%d %d", &amp;x, &amp;y);

    max = x;
    if ( y > max ) { // вложенный блок кода
        max = y;
    } //конец вложенного блока

    return 0;
} // конец блока функции main()</code>
            <p>
                Каждый блок кода определяет область видимости для объявленных в нем переменных. Для понятности, выделим цветом область видимости каждого блока из описанной выше программы:
            </p>
            <figure>
                <img src="scope.png" alt="" width="700">
                <figcaption>Область видимости</figcaption>
            </figure>
            <p>
                 Теперь разберемся, непосредственно, с переменными. Говорить можно много, но понимание приходит в процессе работы. Давайте разберем несколько примеров для улучшения понимания:
            </p>
            <code data-lang="c" data-file="scope.c">#include &lt;stdio.h&gt;

int globalVariable = 10; // глобальная переменная

int main() {
    // внешний блок кода (тело функции main)
    int value = 42; // переменная объявленная во внешнем блоке

    {
        //вложенный блок кода
        printf("internal block: value = %d\n", value);
        printf("internal block: globalVariable = %d\n", globalVariable);
    }
    printf("external block: value = %d\n", value);
    printf("external block: globalVariable = %d\n", globalVariable);

    return 0;
}</code>
        <p>Результат работы программы будет следующим:</p>
        <pre>internal block: value = 42
internal block: globalVariable = 10
external block: value = 42
external block: globalVariable = 10</pre>
        <p>
            Глобальная переменная <code>globalVariable</code> объявлена в глобальной области видимости, поэтому доступна во всех блоках программы. Переменная <code>value</code> объявлена в блоке функции <code>main()</code> (во внешнем блоке), следовательно, она доступна в блоке где она объявлена и во всех вложенных в него блоках. Пременная <code>value</code> — это локальная переменная функции <code>main()</code>, поэтому она не доступна в глобальной области видимости.
        </p>
        <p>
            При изменении значения переменной во вложенных блоках кода, такие изменения будут видны и во внешних блоках, включая блок, в котором объявлена переменная. Продемонстрирую:
        </p>
        <code data-lang="c" data-file="scope.c">#include &lt;stdio.h&gt;

int globalVariable = 10; // глобальная переменная

int main() {
    // внешний блок кода (тело функции main)
    int value = 42; // переменная объявленная во внешнем блоке

    {
        //вложенный блок кода
        printf("internal block: value = %d\n", value);
        printf("internal block: globalVariable = %d\n", globalVariable);
        value += 10;
        globalVariable += 7;
    }
    printf("external block: value = %d\n", value);
    printf("external block: globalVariable = %d\n", globalVariable);

    return 0;
}</code>
        <p>
            Результат:
        </p>
    <pre>internal block: value = 42
internal block: globalVariable = 10
external block: value = 52
external block: globalVariable = 17</pre>
        <p>
            Мы можем объявлять переменные в любом блоке кода, но следует помнить, что переменная, объявленная локально, видна только в том блоке кода, где она объявлена.
        </p>
        <code data-lang="c" data-file="scope.c">#include &lt;stdio.h&gt;

int globalVariable = 10; // глобальная переменная

int main() {
    // внешний блок кода (тело функции main)
    int value = 42; // переменная объявленная во внешнем блоке

    {
        //вложенный блок кода
        int localVariable = 57; // переменная объявлена во вложенном блоке

        printf("internal block: value = %d\n", value);
        printf("internal block: globalVariable = %d\n", globalVariable);
        printf("internal block: localVariable = %d\n", localVariable);
        value += 10;
        globalVariable += 7;
    }
    printf("external block: value = %d\n", value);
    printf("external block: globalVariable = %d\n", globalVariable);
    // localVariable не доступна во внешнем блоке
    printf("external block: localVariable = %d\n", localVariable);
    return 0;
}</code>
        <p>
            При попытке скомпилировать этод код получим характерную ошибку:
        </p>
        <pre>scope.c: error: use of undeclared identifier 'localVariable';</pre>
        <p>
            Следует принять на вооружение тот факт, что имена переменных во внешних и вложенных блоках могут совпадать, при этом программа будет работать вполне корректно.
        </p>
        <code data-lang="c" data-file="scope.c">#include &lt;stdio.h&gt;

int main() {
    int value = 42;

    {
        int value = 57;

        printf("internal block: value = %d\n", value);
    }
    printf("external block: value = %d\n", value);

    return 0;
}</code>
        <p>
            Результатом работы такой программы будет следующее:
        </p>
        <pre>internal block: value = 57
external block: value = 42</pre>
        <div class="co">
                <p>
                   Переменная <code>value</code>, объявленная в блоке функции <code>main()</code> и переменная <code>value</code>, объявленная во вложенном блоке — это разные переменные! Для нас они имеют одинаковое имя, однако значения этих переменных хранятся в разных областях памяти!
                </p>
            </div>
        <p>
            Однако, такой подход к написанию кода затрудняет его понимание. Поэтому не стоит давать переменным одинаковые имена. Даже если они объявлены в разных, по уровню вложенности, блоках. 
        </p>
        <p>
            Мы ведь не можем создать файлы с одинаковым именем в одной папке. Но создав вложенную папку — мы легко сохраним туда одноименный файл. Но стоит нам воспользоваться поиском, мы получим несколько файлов с одинаковым именем, что затруднит работу. Думайте над тем, как назвать переменную, чтобы исключить дубликаты имен.
        </p>
        </section>
        <section>
            <h2 id="function">Функции</h2>
            <p>
                С функциями вы уже знакомы. Для вывода вы активно пользовали функцию <code>printf()</code>, для чтения <code>scanf()</code>, а логику своих программ вы описывали в теле функции <code>main()</code>. Так что функциями вы вполне успешно пользовались. Осталось только разобраться с тем, что же такое функция.
            </p>
            <blockquote>
                Функция — именованный фрагмент программного кода (подпрограмма, процедура), к которому можно обратиться из другого места программы. С именем функции неразрывно связан адрес первой инструкции (оператора), входящей в функцию, которой передаётся управление при обращении к функции. После выполнения функции, управление возвращается обратно в адрес возврата — точку программы, где данная функция была вызвана.
            </blockquote>
            <p>
                Простыми словами, мы можем описать в виде кода некоторую последовательность действий, заключить их в блок кода, именовать его в соответствии со смыслом выполняемых им действий и вынести отдельно. При этом у нас остается возможность обращаться к такому блоку в любом месте нашей программы и нас никто не ограничивает в количестве таких обращений.
            </p>
            <p>
                Но необходимо понимать, что функция должна быть соответствующим образом объявлена и определена. Для объявления функции необходимо указать тип возвращаемого функцией значения, перечислить передаваемые в функцию аргументы, с указанием их типов. Функция определяет собственную, локальную область видимости, куда входят аргументы, передаваемые в функцию, а так же локально объявленные в этой области переменные.Более того, функция вполне может содержать в себе вызовы других функций.
            </p>
            <p>
                Проведем эксперимент:
            </p>
            <code data-lang="c" data-file="functions.c">#include &lt;stdio.h&gt;

int main() {
    int sum = 0;

    { // блок, в котором вычисляется сумма локальных переменных
        int x, y;

        scanf("%d %d", &amp;x, &amp;y);

        sum = x + y;
    }

    printf("%d\n", sum);
    
    return 0;
}</code>
            <p>
                При запуске программы, мы получим вполне корректный результат. Более того, в случае, когда нам необходимо будет посчитать сумму еще раз, мы можем просто скопировать соответствующий блок кода, изменяя лишь имя переменной, в которую следует сохранить результат. 
            </p>
            <p>
                Это может показаться удобным, но только что делать, если необходимо посчитать сумму нескольких пар чисел? Скопировать такой блок несколько раз к ряду? Не думаю, что это хорошая идея. Плюс, если вместо сумы необходимо будет вычислить разность, то в код программы нужно будет внести достаточно большое количество изменений. Поэтому попробуем вынести данный код. Но для начала определим несколько позиций:
            </p>
            <ul>
                <li>данный блок кода необходимо именовать;</li>
                <li>сумму чисел будем возвращать из блока, вместо того, чтобы оперировать глобальными переменными.</li>
            </ul>
            <p>
                Делаем:
            </p>
            <code data-lang="c" data-file="functions.c">#include &lt;stdio.h&gt;

int sum() {
    int x, y;

    scanf("%d %d", &amp;x, &amp;y);

    return x + y;
}

int main() {
    int result = sum();

    printf("%d\n", result);

    return 0;
}</code>
            <p>
                Теперь мы можем в любой момент времени, при необходимости сложить два числа, воспользоваться функцией <code>sum()</code>. Но несколько нелогично в реализации функции, которая занимается сложением двух чисел, что-то считывать. Это некорректно, так как функция должна выполнять одно цельное и логически завершенное действие. Перепишем наш код:
            </p>
            <code data-lang="c" data-file="functions.c">#include &lt;stdio.h&gt;

int sum(int x, int y) {
    return x + y;
}

int main() {
    int a, b;

    scanf("%d %d", &amp;a, &amp;b);

    printf("%d\n", sum(a, b));

    return 0;
}</code>
            <p>
                Что изменилось? Теперь, вместо того, чтобы считывать два числа внутри функции, мы передаем ей числа, подлежащие сложению в виде аргументов. Так как функция возвращает целое число, а результат сложения был необходим только для вывода, можно результат работы функции <code>sum()</code> передать в качестве аргумента в функцию <code>printf()</code>, при этом нигде не хранить результат сложения.
            </p>
        </section>
        <footer>
            <address>
                Автор caiman.
            </address>
            <time datetime="2014-02-10">21.03.2014</time>
        </footer>
    </article>
    <script type="text/javascript" src="https://dl.dropboxusercontent.com/u/31437201/code.js"></script>
</body>
</html>