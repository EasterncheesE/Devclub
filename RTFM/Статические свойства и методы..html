<!DOCTYPE html>
<!-- saved from url=(0037)https://rtfm.devclub.com/statics.html -->
<html lang="ru"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Статические свойства и методы.</title>
    
    <link rel="stylesheet" href="./Статические свойства и методы._files/style.css">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
    <article class="page">
        <h1>Статические свойства и методы</h1>
        <aside class="plan">
            <div class="contents">
                <h2>План</h2>
                <ol>
                    <li><a href="https://rtfm.devclub.com/statics.html#statics">Cтатика</a>
                        <ol>
                            <li><a href="https://rtfm.devclub.com/statics.html#file">Файл</a></li>
                            <li><a href="https://rtfm.devclub.com/statics.html#function">Функция</a></li>
                            <li><a href="https://rtfm.devclub.com/statics.html#class">Класс</a></li>
                        </ol>
                    </li>
                    <li><a href="https://rtfm.devclub.com/statics.html#static_members">Статические свойства и методы</a></li>
                    <li><a href="https://rtfm.devclub.com/statics.html#copy_constructor">Конструктор копирования</a></li>
                    <li><a href="https://rtfm.devclub.com/statics.html#assignment_operator">Оператор присваивания</a></li>
                    <li><a href="https://rtfm.devclub.com/statics.html#rule_of_three">Правило «тройки»</a></li>
                </ol>
            </div>
        </aside>

        <section>
            <h2 id="statics">Cтатика</h2>
            <p>
                Ключевое слово <code>static</code> в языке C++ является довольно интересным, ибо означает разные вещи, в зависимости от применения. Рассморим три варианта.
            </p>
            <h3 id="file">Файл</h3>
            <p>
                Как известно, локальные переменные доступны в пределах блока, в котором они объявлены, а также во всех вложенных блоках. Глобальные переменные доступны во всей программе. Локальные переменные объявляются внутри блока, глобальные — за пределами блоков.
            </p>
            <p>
                Использование ключевого слова <code>static</code> при объявлении глобальной переменной ограничивает область видимости этой переменной файлом. Другими словами, статическая переменная уровня файла видна только внутри файла.
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre></aside><code data-lang="c"><span class="type">static</span> <span class="type">int</span> fileScopeInt; <span class="comment">// переменная уровня файла</span>
<span class="type">float</span> globalScopeFloat;  <span class="comment">// глобальная переменная</span>

<span class="type">int</span> <span class="function">main</span>() {
    <span class="type">double</span> localScopeDouble; <span class="comment">// локальная переменная</span>
}</code></div>

            <h3 id="function">Функция</h3>
            <p>
                По умолчанию, локальные переменные обладают «автоматической продолжительностью жизни» (англ. automatic duration). Это означает, что они уничтожаются, когда выполнение кода покидает область видимости, в которой эти переменные объявлены. Такое поведение можно указать явно с помощью ключевого слова <code>auto</code>, но на практике этим не пользуются.
            </p>
            <p>
                Добавление ключевого слова <code>static</code> при объявлении локальной переменной изменяет это поведение, и переменная переходит к «фиксированной продолжительности жизни» (англ. fixed duration). Такие переменные по прежнему доступны только внутри блока, в котором они объявлены, но инициализируются один раз и не удаляются при выходе из области видимости. Таким образом можно, например, посчитать количество вызовов функции:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre></aside><code data-lang="c"><span class="type">void</span> <span class="function">someFunction</span>() {
    <span class="type">static</span> <span class="type">int</span> count = <span class="number">1</span>;

    <span class="keyword">printf</span>(<span class="string">"function called %d times\n"</span>, count);

    count += <span class="number">1</span>;
}</code></div>

            <h3 id="class">Класс</h3>
            <p>
                Статическими в классе могут быть как атрибуты, так и методы. Область видимости статических членов уровня класса ограничена классом, в котором они объявлены. Для всех экземпляров класса создаётся всего одна копия статического члена, который, при этом, не является частью объекта. Статические члены класса объявляются с использованием ключевого слова <code>static</code>.
            </p>
            <p>
                Типичное применение статический членов класса — хранение и обработка данных, относящихся ко всем экземплярам класса, а не к какому-то конкретному. Например, это может быть счетчик, который подсчитывает общее количество созданных экземляров класса. Каждый раз при создании нового объекта нужно попросту инкрементировать этот счетчик.
            </p>
            <p>
                Так как статические члены класса не относятся к какому-либо конкретному объекту — обращаться к ним нужно используя имя класса:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre><pre>8</pre><pre>9</pre><pre>10</pre><pre>11</pre></aside><code data-lang="c"><span class="type">class <span class="function">X</span></span> {
    <span class="type">static</span> <span class="type">int</span> staticVariable; <span class="comment">// статический атрибут класса</span>

    <span class="type">static</span> <span class="type">void</span> <span class="function">doBook</span>(); <span class="comment">// статический метод</span>
}

<span class="type">int</span> <span class="function">main</span>() {
    <span class="comment">// обращение к статическим членам через имя класса</span>
    X::staticVariable;
    X::<span class="function">doBook</span>();
}</code></div>
        </section>

        <section>
            <h2 id="static_members">Статические свойства и методы</h2>
            <p>
                Статические атрибуты и методы не относятся к конкретным объектам. Они относятся ко всему классу.
                Поэтому после объявления статического члена класса, он существует, даже если отсутствуют экземпляры класса.
                Важной особенностью является то, что объявление статического члена при объявлении класса всего лишь указывает, что в классе есть этот член. Инициализировать статический атрибут или реализовывать статический метод необходимо за пределами объявления класса в области видимости его пространства имен:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre><pre>8</pre><pre>9</pre><pre>10</pre><pre>11</pre><pre>12</pre><pre>13</pre></aside><code data-lang="c"><span class="type">class <span class="function">Book</span></span> {
    <span class="keyword">private</span>:
        <span class="type">static</span> <span class="type">int</span> totalCount;      <span class="comment">// объявление стсатического атрибута</span>

    <span class="keyword">public</span>:
        <span class="type">static</span> <span class="type">int</span> <span class="function">getTotalCount</span>(); <span class="comment">// объявление статического метода</span>
};

<span class="type">int</span> Book::totalCount = <span class="number">0</span>;    <span class="comment">// инициализация статического атрибута</span>

<span class="type">int</span> Book::<span class="function">getTotalCount</span>() {    <span class="comment">// реализация статического метода</span>
    <span class="keyword">return</span> totalCount;
}</code></div>
        <p>
            Как видите, при реализации статического метода можно пользоваться статическими атрибутами и другими статическими методами этого же класса напрямую, без указания пространства имён.
        </p>
        <p>
            Статические атрибуты можно инициализировать другими статическими членами:
        </p>
<div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre><pre>8</pre><pre>9</pre><pre>10</pre><pre>11</pre><pre>12</pre><pre>13</pre><pre>14</pre><pre>15</pre><pre>16</pre><pre>17</pre><pre>18</pre></aside><code data-lang="c"><span class="type">class <span class="function">Book</span></span> {
    <span class="keyword">private</span>:
        <span class="type">static</span> <span class="type">int</span> totalCount;

    <span class="keyword">public</span>:
        <span class="type">static</span> <span class="type">int</span> <span class="function">getTotalCount</span>();
        <span class="type">static</span> <span class="type">int</span> <span class="function">getInitValue</span>();
};

<span class="type">int</span> Book::<span class="function">getInitValue</span>() {
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="type">int</span> Book::<span class="function">getTotalCount</span>() {
    <span class="keyword">return</span> totalCount;
}

<span class="type">int</span> Book::totalCount = Book::<span class="function">getInitValue</span>();</code></div>
        <p>
            Статический метод не может быть константным:
        </p>
        <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre></aside><code data-lang="c"><span class="type">class <span class="function">Book</span></span> {
    <span class="type">static</span> <span class="type">int</span> <span class="function">someMethod</span>() <span class="type">const</span>; <span class="comment">// ошибка компиляции</span>
};</code></div>
        <p>
            Константность метода указывает на то, что метод не может изменять состояние объекта. Но ведь статический метод не относится к конкретному объекту. Поэтому он не может быть константным. По этой же причине в статическом методе нет указателя <code>this</code>.
        </p>
        <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre></aside><code data-lang="c"><span class="type">class <span class="function">Book</span></span> {
    <span class="type">static</span> <span class="type">int</span> <span class="function">someMethod</span>();
};

<span class="type">int</span> Book::<span class="function">someMethod</span>() {
    <span class="keyword">this</span>-&gt;<span class="function">doSomething</span>();    <span class="comment">// ошибка компиляции из-за отсутствия <span class="keyword">this</span></span>
}</code></div>
        <p>
            При попытке использовать <code>this</code> внутри статического метода получим ошибку компиляции:
        </p>
        <pre>error: invalid use of 'this' outside of a non-static member function</pre>
        <p>
            Статический атрибут класса вполне может быть константой, но при этом инициализировать его нужно как константу, например так:
        </p>
        <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre></aside><code data-lang="c"><span class="type">class <span class="function">Book</span></span> {
    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> classConstant;
};

<span class="type">const</span> <span class="type">int</span> Book::classConstant = <span class="number">42</span>;</code></div>
        <p>
            А лучше так:
        </p>
        <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre></aside><code data-lang="c"><span class="type">class <span class="function">Book</span></span> {
    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> classConstant = <span class="number">42</span>;
};</code></div>
        <p>
            Несмотря на то, что статический метод не относится к объектам, нельзя в одном классе объявить два одноимённых метода с одинаковыми аргументами, даже если один из этих методов статический. Этот ньюанс становится очевидным при разнесении класса на заголовок и реализацию.
        </p>
        </section>

        <section>
            <h2 id="copy_constructor">Конструктор копирования</h2>
            <blockquote>
                Конструктором копирования (в англоязычной литературе используется термин <i>copy constructor</i>) называется специальный конструктор в языке программирования C++, применяемый для создания нового объекта как копии уже существующего. Такой конструктор принимает как минимум один аргумент: ссылку на копируемый объект.
            </blockquote>
            <p>
                Копирование объектов в С++ осуществляется засчет конструктора копирования и оператора присваивания, о котором речь пойдет позже.
            </p>
            <p>
                Конструктор копирования первым аргументом принимает ссылку на объект собственного класса, причём константную:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre></aside><code data-lang="c"><span class="type">class <span class="function">Book</span></span> {
    <span class="function">Book</span>(<span class="type">const</span> Book&amp; copy);
};</code></div>
            <p>
                Почему именно ссылку? Потому что если передать объект в функцию по значению — это приведет к неявному копированию объекта. Этим же конструктором. Затем ещё раз. И ещё... В итоге мы заглохнем в глубокой рекурсии.
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre></aside><code data-lang="c"><span class="type">class <span class="function">Book</span></span> {
    <span class="function">Book</span>(<span class="type">const</span> <span class="type">Book</span> copy); <span class="comment">// неправильно — приведет к глубокой рекурсии</span>
};</code></div>
            <p>
                Конструктор копирования вызывается в четырёх случаях:
            </p>
            <p>
                1. Когда объект является возвращаемым значением функции:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre></aside><code data-lang="c"><span class="type">Book</span> getBook {
    <span class="keyword">return</span> <span class="function">Book</span>(); <span class="comment">// при возврате значения произойдет копирование</span>
};</code></div>
            <p>
                2. Когда объект передается функции по значению в качестве аргумента:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre></aside><code data-lang="c"><span class="type">void</span> <span class="function">print</span>(Book book) { <span class="comment">// при передаче по значению произойдет копирование</span>
    std::cout &lt;&lt; book &lt;&lt; std::endl;
};</code></div>
            <p>
                3. Когда объект конструируется на основе другого объекта (того же класса):
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre></aside><code data-lang="c"><span class="type">int</span> <span class="function">main</span>() {
    <span class="type">Book</span> book1 = <span class="function">Book</span>();
    <span class="type">Book</span> book2 = <span class="function">Book</span>(book1);   <span class="comment">// явный вызов конструктора копирования</span>
    <span class="type">Book</span> book3 = book2;         <span class="comment">// неявный вызов конструктора копирования</span>

    <span class="keyword">return</span> <span class="number">0</span>;
};</code></div>
            <p>
                4. Когда компилятор генерирует временный объект (как в первом и втором случаях выше; как явное преобразование и т.д.)
            </p>
            <h3 id="copy_and_statics">Копирование объектов и статика</h3>
            <p>
                Допустим, у нас есть класс <code>Book</code>, в котором есть статический счетчик книг. У каждой книги есть название и уникальный идентификатор:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre><pre>8</pre><pre>9</pre><pre>10</pre><pre>11</pre><pre>12</pre><pre>13</pre><pre>14</pre><pre>15</pre><pre>16</pre><pre>17</pre><pre>18</pre><pre>19</pre><pre>20</pre><pre>21</pre><pre>22</pre><pre>23</pre><pre>24</pre><pre>25</pre><pre>26</pre><pre>27</pre><pre>28</pre><pre>29</pre><pre>30</pre><pre>31</pre><pre>32</pre><pre>33</pre><pre>34</pre><pre>35</pre><pre>36</pre><pre>37</pre><pre>38</pre><pre>39</pre><pre>40</pre><pre>41</pre><pre>42</pre><pre>43</pre><pre>44</pre><pre>45</pre><pre>46</pre><pre>47</pre><pre>48</pre><pre>49</pre><pre>50</pre><pre>51</pre><pre>52</pre><pre>53</pre><pre>54</pre><pre>55</pre><pre>56</pre><pre>57</pre><pre>58</pre><pre>59</pre><pre>60</pre><pre>61</pre><pre>62</pre></aside><code data-lang="c"><span class="directive">#include &lt;iostream&gt;</span>

<span class="type">class <span class="function">Book</span></span> {
    <span class="keyword">private</span>:
        <span class="type">int</span> id;
        std::string title;
    <span class="keyword">public</span>:
        <span class="type">static</span> <span class="type">int</span> totalBooks;
        <span class="type">static</span> <span class="type">int</span> lastId;

    <span class="keyword">public</span>:
        <span class="function">Book</span>(<span class="type">const</span> std::string&amp; title) {
            totalBooks += <span class="number">1</span>;
            lastId += <span class="number">1</span>;
            <span class="keyword">this</span>-&gt;id = lastId;
            <span class="keyword">this</span>-&gt;title = title;
        }

        <span class="function">~Book</span>() {
            totalBooks -= <span class="number">1</span>;
        }

        <span class="type">int</span> <span class="function">getId</span>() <span class="type">const</span> {
            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;
        }

        <span class="type">const</span> std::string&amp; <span class="function">getTitle</span>() <span class="type">const</span> {
            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;title;
        }
};

<span class="type">int</span> Book::totalBooks = <span class="number">0</span>;
<span class="type">int</span> Book::lastId     = <span class="number">0</span>;


<span class="type">int</span> <span class="function">main</span>() {
    <span class="type">Book</span> *book1 = <span class="keyword">new</span> <span class="function">Book</span>(<span class="string">"Gulliver"</span>);
    <span class="type">Book</span> *book2 = <span class="keyword">new</span> <span class="function">Book</span>(<span class="string">"Predator"</span>);
    <span class="type">Book</span> *book3 = <span class="keyword">new</span> <span class="function">Book</span>(<span class="string">"Lord of the Rings"</span>);

    std::cout &lt;&lt; <span class="string">"book1 id: "</span> &lt;&lt; book1-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book1-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">1</span></span>
    std::cout &lt;&lt; <span class="string">"book2 id: "</span> &lt;&lt; book2-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book2-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">2</span></span>
    std::cout &lt;&lt; <span class="string">"book3 id: "</span> &lt;&lt; book3-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book3-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">3</span></span>

    std::cout &lt;&lt; <span class="string">"totalBooks: "</span> &lt;&lt; Book::totalBooks &lt;&lt; std::endl; <span class="comment">// totalBooks: <span class="number">3</span></span>

    <span class="keyword">delete</span> book1;
    <span class="keyword">delete</span> book3;

    std::cout &lt;&lt; <span class="string">"totalBooks: "</span> &lt;&lt; Book::totalBooks &lt;&lt; std::endl; <span class="comment">// totalBooks: <span class="number">1</span></span>

    <span class="keyword">delete</span> book2;

    std::cout &lt;&lt; <span class="string">"totalBooks: "</span> &lt;&lt; Book::totalBooks &lt;&lt; std::endl; <span class="comment">// totalBooks: <span class="number">0</span></span>

    book1 = <span class="keyword">new</span> <span class="function">Book</span>(<span class="string">"Bible"</span>);

    std::cout &lt;&lt; <span class="string">"book1 id: "</span> &lt;&lt; book1-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book1-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">1</span></span>
    std::cout &lt;&lt; <span class="string">"totalBooks: "</span> &lt;&lt; Book::totalBooks &lt;&lt; std::endl; <span class="comment">// totalBooks: <span class="number">1</span></span>

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></div>
        <p>
            Статический счетчик увеличивается на 1 каждый раз, когда создается новый объект, и уменьшается на 1 при уничтожении объекта. Каждый объект получает уникальный идентификатор при создании и увеличивает на 1 счетчик идентификаторов. Вроде понятно.
        </p>
        <p>
            А теперь давайте сделаем копию книги:
        </p>
        <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre><pre>8</pre><pre>9</pre><pre>10</pre><pre>11</pre><pre>12</pre><pre>13</pre><pre>14</pre><pre>15</pre><pre>16</pre><pre>17</pre><pre>18</pre><pre>19</pre><pre>20</pre><pre>21</pre><pre>22</pre><pre>23</pre><pre>24</pre><pre>25</pre><pre>26</pre><pre>27</pre><pre>28</pre><pre>29</pre><pre>30</pre><pre>31</pre><pre>32</pre><pre>33</pre><pre>34</pre><pre>35</pre><pre>36</pre><pre>37</pre><pre>38</pre><pre>39</pre><pre>40</pre><pre>41</pre><pre>42</pre><pre>43</pre><pre>44</pre><pre>45</pre><pre>46</pre><pre>47</pre><pre>48</pre></aside><code data-lang="c"><span class="directive">#include &lt;iostream&gt;</span>

<span class="type">class <span class="function">Book</span></span> {
    <span class="keyword">private</span>:
        <span class="type">int</span> id;
        std::string title;
    <span class="keyword">public</span>:
        <span class="type">static</span> <span class="type">int</span> totalBooks;
        <span class="type">static</span> <span class="type">int</span> lastId;

    <span class="keyword">public</span>:
        <span class="function">Book</span>(<span class="type">const</span> std::string&amp; title) {
            totalBooks += <span class="number">1</span>;
            lastId     += <span class="number">1</span>;
            <span class="keyword">this</span>-&gt;id    = lastId;
            <span class="keyword">this</span>-&gt;title = title;
        }

        <span class="function">~Book</span>() {
            totalBooks -= <span class="number">1</span>;
        }

        <span class="type">int</span> <span class="function">getId</span>() <span class="type">const</span> {
            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;
        }

        <span class="type">const</span> std::string&amp; <span class="function">getTitle</span>() <span class="type">const</span> {
            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;title;
        }
};

<span class="type">int</span> Book::totalBooks = <span class="number">0</span>;
<span class="type">int</span> Book::lastId     = <span class="number">0</span>;


<span class="type">int</span> <span class="function">main</span>() {
    <span class="type">Book</span> *book1 = <span class="keyword">new</span> <span class="function">Book</span>(<span class="string">"Gulliver"</span>);
    <span class="type">Book</span> *book2 = <span class="keyword">new</span> <span class="function">Book</span>(*book1);

    std::cout &lt;&lt; <span class="string">"book1 id: "</span> &lt;&lt; book1-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book1-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">1</span></span>
    std::cout &lt;&lt; <span class="string">"book2 id: "</span> &lt;&lt; book2-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book2-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book2 id = <span class="number">1</span></span>
    std::cout &lt;&lt; <span class="string">"totalBooks: "</span> &lt;&lt; Book::totalBooks &lt;&lt; std::endl; <span class="comment">// totalBooks: <span class="number">1</span></span>

    <span class="keyword">delete</span> book1;
    <span class="keyword">delete</span> book2;

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></div>
        <p>
            В результате копирования получаем два объекта с одинаковым идентификатором, а счетчик объектов по-прежнему показывает, что у нас всего один объект. По логике вещей, счетчик объектов должен увеличиться, ведь мы создали еще один объект. Да и идентификатор объекта должен быть уникальным.
        </p>
        <p>
            Исправить сложившуюся ситуацию поможет конструктор копирования. Давайте внесём изменения:
        </p>
        <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre><pre>8</pre><pre>9</pre><pre>10</pre><pre>11</pre><pre>12</pre><pre>13</pre><pre>14</pre><pre>15</pre><pre>16</pre><pre>17</pre><pre>18</pre><pre>19</pre><pre>20</pre><pre>21</pre><pre>22</pre><pre>23</pre><pre>24</pre><pre>25</pre><pre>26</pre><pre>27</pre><pre>28</pre><pre>29</pre><pre>30</pre><pre>31</pre><pre>32</pre><pre>33</pre><pre>34</pre><pre>35</pre><pre>36</pre><pre>37</pre><pre>38</pre><pre>39</pre><pre>40</pre><pre>41</pre><pre>42</pre><pre>43</pre><pre>44</pre><pre>45</pre><pre>46</pre><pre>47</pre><pre>48</pre><pre>49</pre><pre>50</pre><pre>51</pre><pre>52</pre><pre>53</pre><pre>54</pre><pre>55</pre><pre>56</pre></aside><code data-lang="c"><span class="directive">#include &lt;iostream&gt;</span>

<span class="type">class <span class="function">Book</span></span> {
    <span class="keyword">private</span>:
        <span class="type">int</span> id;
        std::string title;
    <span class="keyword">public</span>:
        <span class="type">static</span> <span class="type">int</span> totalBooks;
        <span class="type">static</span> <span class="type">int</span> lastId;

    <span class="keyword">public</span>:
        <span class="function">Book</span>(<span class="type">const</span> std::string&amp; title) {
            totalBooks += <span class="number">1</span>;
            lastId     += <span class="number">1</span>;
            <span class="keyword">this</span>-&gt;id    = lastId;
            <span class="keyword">this</span>-&gt;title = title;
        }

        <span class="comment">// добавим конструктор копирования</span>
        <span class="function">Book</span>(<span class="type">const</span> Book&amp; copy) {
            totalBooks += <span class="number">1</span>;          <span class="comment">// увеличиваем счетчик объектов</span>
            lastId     += <span class="number">1</span>;          <span class="comment">// увеличиваем счетчик идентификаторов</span>
            <span class="keyword">this</span>-&gt;id    = lastId;     <span class="comment">// присваиваем копии уникальный идентификатор</span>
            <span class="keyword">this</span>-&gt;title = copy.title; <span class="comment">// копируем остальные поля</span>
        }

        <span class="function">~Book</span>() {
            totalBooks -= <span class="number">1</span>;
        }

        <span class="type">int</span> <span class="function">getId</span>() <span class="type">const</span> {
            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;
        }

        <span class="type">const</span> std::string&amp; <span class="function">getTitle</span>() <span class="type">const</span> {
            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;title;
        }
};

<span class="type">int</span> Book::totalBooks = <span class="number">0</span>;
<span class="type">int</span> Book::lastId     = <span class="number">0</span>;


<span class="type">int</span> <span class="function">main</span>() {
    <span class="type">Book</span> *book1 = <span class="keyword">new</span> <span class="function">Book</span>(<span class="string">"Gulliver"</span>);
    <span class="type">Book</span> *book2 = <span class="keyword">new</span> <span class="function">Book</span>(*book1);

    std::cout &lt;&lt; <span class="string">"book1 id: "</span> &lt;&lt; book1-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book1-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">1</span></span>
    std::cout &lt;&lt; <span class="string">"book2 id: "</span> &lt;&lt; book2-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book2-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">2</span></span>
    std::cout &lt;&lt; <span class="string">"totalBooks: "</span> &lt;&lt; Book::totalBooks &lt;&lt; std::endl; <span class="comment">// totalBooks: <span class="number">3</span></span>

    <span class="keyword">delete</span> book1;
    <span class="keyword">delete</span> book2;

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></div>
        <p>
            Теперь копирование работает правильно, так как мы и хотели. При копировании увеличиватся количество объектов, и каждый объект обладает уникальным идентификатором, даже если объект является копией.
        </p>
        </section>

        <section>
            <h2 id="assignment_operator">Оператор присваивания</h2>
            <p>
                Ещё одним способом копирования объектов является оператор присваивания:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre><pre>8</pre><pre>9</pre><pre>10</pre></aside><code data-lang="c"><span class="type">int</span> <span class="function">main</span>() {
    <span class="type">Book</span> book1 = <span class="function">Book</span>();
    <span class="type">Book</span> book2 = <span class="function">Book</span>(book1);   <span class="comment">// явный вызов конструктора копирования</span>
    <span class="type">Book</span> book3 = book2;         <span class="comment">// неявный вызов конструктора копирования</span>
    <span class="type">Book</span> book4;

    book4 = book3;              <span class="comment">// вызов оператора присваивания (operator=)</span>

    <span class="keyword">return</span> <span class="number">0</span>;
};</code></div>
            <p>
                Ситуация с оператором присваивания обстоит так же, как и в случае с конструктором копирования. Если мы самостоятельно не определяем оператор присваивания, который используется для присваивания объектов одного класса друг другу — компилятор автоматически его генерирует. Для класса <code>Book</code> он выглядит вот так:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre></aside><code data-lang="c">Book&amp; operator=(<span class="type">const</span> Book&amp; copy) {
    <span class="keyword">this</span>-&gt;id    = copy.id;
    <span class="keyword">this</span>-&gt;title = copy.title;

    <span class="keyword">return</span> *<span class="keyword">this</span>;
}</code></div>
            <p>
                Сгенерированный оператор присваивания выполняет простое присваивание значений каждого из атрибутов одного объекта атрибутам другого. Как и в случае с конструктором копирования, изменения не затрачивают статические свойства.
            </p>
            <p>
                Поэтому, при работе со статикой, нужно переопределять не только конструктор копирования, но и оператор присваивания. Добавим немного кодца в класс <code>Book</code>:
            </p>
            <div class="code"><aside><pre>1</pre><pre>2</pre><pre>3</pre><pre>4</pre><pre>5</pre><pre>6</pre><pre>7</pre><pre>8</pre><pre>9</pre><pre>10</pre><pre>11</pre><pre>12</pre><pre>13</pre><pre>14</pre><pre>15</pre><pre>16</pre><pre>17</pre><pre>18</pre><pre>19</pre><pre>20</pre><pre>21</pre><pre>22</pre><pre>23</pre><pre>24</pre><pre>25</pre><pre>26</pre><pre>27</pre><pre>28</pre><pre>29</pre><pre>30</pre><pre>31</pre><pre>32</pre><pre>33</pre><pre>34</pre><pre>35</pre><pre>36</pre><pre>37</pre><pre>38</pre><pre>39</pre><pre>40</pre><pre>41</pre><pre>42</pre><pre>43</pre><pre>44</pre><pre>45</pre><pre>46</pre><pre>47</pre><pre>48</pre><pre>49</pre><pre>50</pre><pre>51</pre><pre>52</pre><pre>53</pre><pre>54</pre><pre>55</pre><pre>56</pre><pre>57</pre><pre>58</pre><pre>59</pre><pre>60</pre><pre>61</pre><pre>62</pre><pre>63</pre><pre>64</pre><pre>65</pre><pre>66</pre><pre>67</pre><pre>68</pre><pre>69</pre><pre>70</pre></aside><code data-lang="c"><span class="directive">#include &lt;iostream&gt;</span>

<span class="type">class <span class="function">Book</span></span> {
    <span class="keyword">private</span>:
        <span class="type">int</span> id;
        std::string title;
    <span class="keyword">public</span>:
        <span class="type">static</span> <span class="type">int</span> totalBooks;
        <span class="type">static</span> <span class="type">int</span> lastId;

    <span class="keyword">public</span>:
        <span class="function">Book</span>(<span class="type">const</span> std::string&amp; title) {
            totalBooks += <span class="number">1</span>;
            lastId     += <span class="number">1</span>;
            <span class="keyword">this</span>-&gt;id    = lastId;
            <span class="keyword">this</span>-&gt;title = title;
        }

        <span class="comment">// конструктор копирования</span>
        <span class="function">Book</span>(<span class="type">const</span> Book&amp; copy) {
            totalBooks += <span class="number">1</span>;
            lastId     += <span class="number">1</span>;
            <span class="keyword">this</span>-&gt;id    = lastId;
            <span class="keyword">this</span>-&gt;title = copy.title;
        }

        <span class="comment">// оператор присваивания</span>
        Book&amp; operator=(<span class="type">const</span> Book&amp; copy) {
            <span class="keyword">this</span>-&gt;title = copy.title; <span class="comment">// копируем остальные поля</span>

            <span class="keyword">return</span> *<span class="keyword">this</span>;
        }

        <span class="function">~Book</span>() {
            totalBooks -= <span class="number">1</span>;
        }

        <span class="type">int</span> <span class="function">getId</span>() <span class="type">const</span> {
            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;
        }

        <span class="type">const</span> std::string&amp; <span class="function">getTitle</span>() <span class="type">const</span> {
            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;title;
        }
};

<span class="type">int</span> Book::totalBooks = <span class="number">0</span>;
<span class="type">int</span> Book::lastId     = <span class="number">0</span>;


<span class="type">int</span> <span class="function">main</span>() {
    <span class="type">Book</span> *book1 = <span class="keyword">new</span> <span class="function">Book</span>(<span class="string">"Gulliver"</span>);
    <span class="type">Book</span> *book2 = <span class="keyword">new</span> <span class="function">Book</span>(*book1);

    std::cout &lt;&lt; <span class="string">"book1 id: "</span> &lt;&lt; book1-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book1-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">1</span></span>
    std::cout &lt;&lt; <span class="string">"book2 id: "</span> &lt;&lt; book2-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book2-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">2</span></span>
    std::cout &lt;&lt; <span class="string">"totalBooks: "</span> &lt;&lt; Book::totalBooks &lt;&lt; std::endl; <span class="comment">// totalBooks: <span class="number">3</span></span>

    *book1 = *book2;

    std::cout &lt;&lt; <span class="string">"book1 id: "</span> &lt;&lt; book1-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book1-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">1</span></span>
    std::cout &lt;&lt; <span class="string">"book2 id: "</span> &lt;&lt; book2-&gt;<span class="function">getId</span>() &lt;&lt; <span class="string">", title: "</span> &lt;&lt; book2-&gt;<span class="function">getTitle</span>() &lt;&lt; std::endl;    <span class="comment">// book1 id = <span class="number">2</span></span>
    std::cout &lt;&lt; <span class="string">"totalBooks: "</span> &lt;&lt; Book::totalBooks &lt;&lt; std::endl; <span class="comment">// totalBooks: <span class="number">3</span></span>


    <span class="keyword">delete</span> book1;
    <span class="keyword">delete</span> book2;

    <span class="keyword">return</span> <span class="number">0</span>;
}</code></div>
        <p>
            При использовании оператора присваивания для копирования, мы используем два готовых объекта. Мы не создаём новые объекты. Поэтому изменять значение глобального счетчика объектов не нужно. По этой же причине не нужно изменять идентификаторы созданных объектов. В нашем случае, при присваивании необходимо просто скопировать нужные поля (title).
        </p>
        </section>

        <section>
            <h2 id="rule_of_three">Правило «тройки»</h2>
            <p>
                 Практика показывает, что в случаях, когда необходимо переопределить один из следующих методов:
            </p>
            <ol>
                <li>Деструктор</li>
                <li>Конструктор копирования</li>
                <li>Оператор присваивания копированием</li>
            </ol>
            <p>
                необходимо переопределять все три метода.
            </p>
            <p>
                Эти три метода автоматически генерируются компилятором. И есть подозрение, что если функционал одного из них вас не устраивает — не устраивает и поведение двух других.
            </p>

            <p>
                Если вы не хотите выгребать непонятные баги в вашем чудесном программном обеспечении — следуйте этому простому правилу. Чуть более подробно об этом <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D1%82%D1%80%D1%91%D1%85_(C%2B%2B_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)">на википедии</a>.
            </p>


        </section>

        <footer>
            <address>
                Автор X-Treem.
            </address>
            <time datetime="2013-12-13">13.12.2013</time>
        </footer>
    </article>
    <script type="text/javascript" src="./Статические свойства и методы._files/code.js"></script>


</body></html>