<!DOCTYPE html>
<!--[if IE 7]>
<html lang="ru" class="ie7">
<![endif]-->
<!--[if IE 8]>
<html lang="ru" class="ie8">
<![endif]-->
<!--[if (lt IE 7)|(gt IE 8)]><!-->
<html lang="ru">
<!--<![endif]-->
<head>
    <title>Немного чтива</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://dl.dropboxusercontent.com/u/31437201/article.css">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
	<article class="page">
        <h1>Немного чтива</h1>
        <aside class="plan">
            <div class="contents">
                <h2>План</h2>
                <ol>
                    <li><a href="#history">Немного истории</a></li>
                    <li><a href="#main">Коротко о главном</a></li>
                    <li><a href="#terminal">Это страшное слово - терминал</a></li>
                    <li><a href="#code">Пишем руками</a></li>
                </ol>
            </div>
        </aside>
        <section>
            <h2 id="history">Немного истории</h2>
            <p>
            	В начале было слово. Потом два слова. Потом несколько. Улавливаете? Происходил прогресс. Года сменяли годы, поколения сменяли поколения, затем пришел кто-то, назвал это цикличностью и стало неинтересно. Людей стали интересовать иные развлечения. Человечество веселилось: обезьяны с собаками улетели в космос, потом они вернулись и туда улетели люди, человек покорил огонь и воду, землю и воздух. Появлялись новые слова и аббревиатуры: ГМО, ДНК, электрификация, фломастер и тысячи других. Мы научились понимать и использовать окружающий нас мир, превращать воду в вино и во что <a href="http://ru.wikipedia.org/wiki/Водка">похуже</a>, мы научились изготавливать много полезного и нужного, мы научились выплавлять сталь. Хотя, ходят слухи, что с плавлением стали <a href="http://ru.wikipedia.org/wiki/Мао_Цзэдун">некоторые из нас</a> явно перебарщивали.
            </p>
            <p>
            	Люди сделали многое, и это многое люди сделали в большом количестве. Косяками носились подводные лодки, стаями порхали самолеты и выходили на орбиту спутники. Крутились тысячи механизмов, двигались миллионы машин. Человечество называло это революцией, но понимало, что всеми этими чудесами необходимо управлять. Процессы необходимо автоматизировать, синхронизировать и сделать с ними еще очень много непонятных слов. Имеющиеся ресурсы в количестве армии седовласых бухгалтеров и менеджеров среднего звена уже не справлялись с поставленными задачами, бюрократическая машина давала трещину. Казалось никто не в силах это остановить. В это трудное время были нужны герои, ибо их нехватка чувствовалась особенно остро. И было пророчество, что герои придут. Но пришли мы - операторы ЭВМ и инженеры-программисты. Некто Нео, задержался, поэтому начинать спасать мир пришлось без него.
            </p>
            <p>
                Вот так вот. Всего два абзаца получилось. Но там вся суть первых ста страниц типичных самоучителей и учебников программирования, я гарантирую это. Нас же таковые не интересуют. Мы практики, поэтому размышления оставим мыслителям и философам, в конце концов, это их хлеб. Согласны? Замечательно, значит далее говорить будем по существу. Но если вас таки интересует эволюция ЭВМ и другие бородатые легенды, спросите <a href="https://ru.wikipedia.org/wiki/Заглавная_страница">википузиков</a>, они в курсе дела.
            </p>  
		</section>
        <section>
            <h2 id="history">Коротко о главном</h2>
            <p>
                Перед тем как начать, давайте разрешим несколько спорных моментов:
                <ul>
                    <li>
                        <a href="https://www.google.com.ua">google</a> - наш друг. Не стоит пренебрегать этим замечательным инструментом. По опыту скажу, что большинство проблем возникает из-за неумения его пользовать.
                    </li>
                    <li>
                        Эксперимент - наш друг. Можно несколько часов провести в раздумьях, что будет в результате выполнения какого-то кода, а можно один раз его написать и выполнить. Примите на вооружение.
                    </li>
                    <li>
                        <a href="https://my.devclub.com.ua/forum/">Форум</a> - наш друг. Не бойтесь задавать вопросы. Бойтесь ответов.
                    </li>
                </ul>
            </p>
            <p>
                Далее, еще один список, который сократит растраты бесценного времени:
                <ul>
                    <li>
                        Отвыкайте гуглить на русском. Ничего хорошего все равно не найдете. Это касается и чтения русскоязычной википедии. Проблемы с английским - учите. Пригодится чуть менее, чем везде.
                    </li>
                    <li>
                        Читайте официальную документацию. Разработчики языков программирования, обычно, люди неглупые. Поэтому пишут предельно коротко и по существу.
                    </li>
                    <li>
                        Читайте ошибки компилятора. Компилятор пытается вам намекнуть, если у вас что-то не работает. Не стоит игнорировать. Если совсем уж непонятно, копируем ошибку, вставляем в форму отправки запросов на известном <a href="https://www.google.com.ua">сайте</a> и нажимаем <code>Enter</code>. Результат, как правило, среди первых трех-пяти ссылок.
                    </li>
                </ul>
            </p>
        </section>
        <section>
            <h2 id="terminal">Это страшное слово - терминал</h2>
            <p>
                Самое время поговорить о инструментах, которые мы используем. Пользователи операционной системы Windows во время своего обучения будут активно пользовать <a href="http://www.mingw.org">MinGW</a>. Или, после некоторых размышлений, сносим к чертям Windows и ставим Linux.
            </p>
            <p>
                В свою очередь, MinGW — это <a href="http://ru.wikipedia.org/wiki/Командная_оболочка_UNIX">юниксовый шелл</a>, со всеми вытекающими отсюда последствиями. Попробуем разобраться с тем, как его использовать.
            </p>
            <p>Скачать MinGW можно <a href="http://dl.dropboxusercontent.com/u/10707015/MinGW.exe">тут</a>. Данная сборка уже настроена для пользования нашими заботливыми руками.</p>
            <h3>Команды MinGW</h3>
            <table>
                <thead>
                    <tr>
                        <th>Команда (писать в терминал)</th>
                        <th>Описание</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><kbd>npp</kbd></td><td>открываем редактор Notepad++</td></tr>
                    <tr><td><kbd>npp &lt;имя файла&gt;</kbd></td><td>открываем файл с указанием его имени (если файла нет, он будет создан)</td></tr>
                    <tr><td><kbd>gcc</kbd></td><td>запускаем компилятор</td></tr>
                    <tr><td><kbd>gcc [имя файла с исходным кодом]</kbd></td><td>компиляция файла. В результате этого действия получаем исполняемый файл a.exe.</td></tr>
                    <tr><td><kbd>clear</kbd></td><td>очищаем рабочую область</td></tr>
                    <tr><td><kbd>ls</kbd></td><td>получаем список файлов в директории</td></tr>
                    <tr><td><kbd>ls -la</kbd></td><td>получаем список файлов в директории + дополнительная информация</td></tr>
                    <tr><td><kbd>pwd</kbd></td><td>выводим на экран имя рабочего каталоги и путь к нему</td></tr>
                    <tr><td><kbd>cd ..</kbd></td><td>переходим в директорию уровнем выше</td></tr>
                    <tr><td><kbd>cd &lt;имя директории&gt;</kbd></td><td>переходим в выбранную директорию</td></tr>
                    <tr><td><kbd>cd /</kbd></td><td>переходим в корневую директорию</td></tr>
                    <tr><td><kbd>cd ~</kbd></td><td>переходим в домашнюю директорию</td></tr>
                    <tr><td><kbd>rm &lt;имя файла&gt;</kbd></td><td>удаляем файл</td></tr>
                    <tr><td><kbd>rm *</kbd></td><td>удаляем все файлы в текущей директории</td></tr>
                    <tr><td><kbd>rm -R &lt;имя директории&gt;</kbd></td><td>удаляем директорию вместе с ее содержимым</td></tr>
                    <tr><td><kbd>touch &lt;имя файла&gt;</kbd></td><td>создаем файл с указанным именем</td></tr>
                    <tr><td><kbd>mkdir &lt;имя директории&gt;</kbd></td><td>создаем директорию с указанным именем</td></tr>
                    <tr><td><kbd>rmdir &lt;имя директории&gt;</kbd></td><td>удаляем директорию с указанным именем</td></tr>
                    <tr><td><kbd>[имя программы] > [имя файла]</kbd></td><td>перенаправляем вывод программы в файл</td></tr>
                    <tr><td><kbd>cat [имя файла]</kbd></td><td>смотрим содержимое файла</td></tr>

                </tbody>
            </table>
            <p>
                Свои первые эксперименты можете производить уже на данном этапе. Например можно написать программу:
            </p>
            <code data-lang="c" data-file="hello.c">#include &lt;stdio.h&gt;

int main() {
    printf("Hello, world!\n");
    return 0;   
}</code>
            <p>Затем выполним следующее:</p>
            <kbd>gcc hello.c -o hello.exe</kbd>
            <kbd>ls</kbd>
            <p>получим:</p>
            <pre>hello.c hello.exe</pre>
            <p>выполним:</p>
            <kbd>hello.exe</kbd>
            <p>получим:</p>
            <pre>Hello, world!</pre>
            <p>Отлично! Для начала неплохо. Теперь выполним следующую команду:</p>
            <kbd>hello.exe > hello.txt</kbd>
            <kbd>ls</kbd>
            <p>получим:</p>
            <pre>hello.c hello.exe hello.txt</pre>
            <p>Мы перенаправили вывод программы hello.exe в файл hello.txt. Так как файла hello.txt на момент исполнения программы не существовала, он был создан. Теперь посмотрим что было записано в файл:</p>
            <kbd>cat hello.txt</kbd>
            <p>получим:</p>
            <pre>Hello, world!</pre>
        </section>
        <section>
            <h2 id="code">Пишем руками</h2>
            <h3>Названия.</h3>
            <p>
                Название переменной должно в полной мере отображать ее содержимое. Исходя из этого не сложно догадаться, что переменная, которая хранит результат сложения должна иметь назвиние sum, результат вычитания difference либо diff, общее количество чего либо amount или total. Продолжать можно бесконечно, руководствуйтесь здравым смыслом. Перегибать не стоит, название типа numbersOfRowsInCurrentSection избыточно.
            </p> 
            <h3>Транслит (transljatsija rodnogo jazika latinitsey).</h3>
            <p>
                Даже думать не смейте. Попадется вам что-то типа:
<code data-lang="c">int liczba;
int kwota, dywidenda, dzielnik;</code>
Долго будете гадать, что имел в виду польский программист руками.
            </p>
            <h3>Перечисление.</h3>
            <p>
                Иногда возникает необходимость обьявить несколько подобных переменных для хранения, например, неизвесных в линейных уравнениях либо любого другого набора чисел.
            </p>
            <p>
                Адекватные решения:
                <code data-lang="c">int x, y, z;
int a, b, c, d;</code>
Главное запомнить небольшое правило, если уж перечислять английский алфавит, то делать это нужно по порядку.
            </p>
            <p>
                Неадекват:
                <code data-lang="c">int num1, num2, num3, ...;
int first, second, third, fourth, ...;</code>
            </p>
            <h3>Семантическая подобность.</h3>
            <p>
<code data-lang="c">int divisor, dividend, max, min, result;</code>

В этом случае divisor, dividend - переменные, которые участвуют в арифметических выражениях, max, min - хранят некие подобные по логике конечные значения, result - хранит результат каких либо ваших действий. Вполне логично и понятно, что и обьявлять их нужно следующим образом:
<code data-lang="c">int divisor, dividend;
int max, min;
int result;</code>
            </p>
            <h3>Ошибки перевода.</h3>
            <p>
                Необходимо заметить, что все определения, обозначения и имена в вашей программе необходимо писать на английском языке. Так делают не только в Украине, но и в России, Германии, Англии и прочем "остальном мире". Поэтому если вы не уверены в переводе, воспользуйтесь словарем / переводчиком, дабы исключить такие ляпы как:
<code data-lang="c">int lenght, devident, devizor ...;</code>
            </p>
                <h3>Область видимости.</h3>
            <p>
                Обьявлять переменные, которые нужны только в теле цикла, следует ВНЕЗАПНО! в теле цикла. Итераторы, если они не глобальны, в заголовке цикла. Это частный случай. В общем логика должна быть такова: переменные следует обьявлять в том блоке кода, где они используются. Если переменная нужна в пределах вложенного блока то, более глобально ее объявлять не следует.
            </p>

            <h3>Ну и конечно Капитан Очевидность.</h3>
            <code data-lang="c">int variable;</code>
            <p>
                Вспоминается сразу коньяк "Коньяк", магазин "Магазин" и другие звучные названия. Это даже не объявление переменной - это констатация факта.
            </p>

            <h3>Вложенность кода.</h3>
            <p>
                Бывают ситуации, когда внутри одной управляющей конструкции используется другая. Это нормальная ситуация. Но ситуации подобные этой:
                <code data-lang="c">for ( int i = 0; i < 5; i++ ) {
if ( i % 2 == 0 )
{
result += 1;
}
else
{
result -= 1;
}
}</code>
вызывают негодование православных программистов. Восприятие кода существенно облегчается, если код оформить следующим образом:
<code data-lang="c">for ( int i = 0; i < 5; i++ ) {
    if ( i % 2 == 0 ) {
        result += 1;
    } else {
        result -= 1;
    }
}</code>
            </p>
            <p>
И, таки, да! Операторы типа ++ и -- вполне органично вписываются в заголовок цикла, но в арифметических действиях следует использовать операторы += и -=; Например:
<code data-lang="c">for ( ... ; ...; i++ );
for ( ... ; ...; i-- );</code>
выглядит вполне логично. В то время как
<code data-lang="c">if ( ... ) {
    result++;
    amount--;
}</code>
не в полне корректно. Следует использовать
<code data-lang="c">if ( ... ) {
    result += 1;
    amount -= 1;
}</code>
            </p>

            <h3>Функции.</h3>
            <p>
                Это отдельная мощная тема для беседы. Имя функции должно, сколько это возможно, лаконично и в полном объеме передавать ее смысловую нагрузку. При написании функции необходимо помнить простое правило: функция должна быть универсальной и выполнять одно логически завершенное действие.
            </p>
            <p>
Достаточно легко понять следующую функцию:
<code data-lang="c">int ariProg(int first, int step, int index) {
    ...
}</code>
Но в то же время если записать вот так:
<code data-lang="c">int myFunction(int start, int number, int counter) {
    ...
}</code>
смысл функции совершенно непонятен. Необходимо анализировать реализацию, чтобы разобраться, в чем, собственно, суть. Мне безразлично, как вы напишете, но что будет, если вам необходимо будет через некоторое время использовать свое решение, либо изменить логику программы? Потратите лишний час-два на анализ своего собственного кода? Успехов!
            </p>

<h3>Макросы.</h3>
            <p>
                Макросы полезны. В названиях макросов используйте те же правила, что и в названиях переменных. Но кроме этого в макросах сокрыт еще и сакральный смысл! И смысл макросов - это избавить ваш код от "магических" констант. Например в коде:
            <code data-lang="c">if ( value % 42 == 0 ) {
    value -= 42;
    result = some function(value, 42);
    if ( result < 42 ) {
        result += 42;
        value - ( result * 42 );
    }
}</code>
как то не очень очевидно, какая константа что обозначает. К тому же, при необходимости изменить какое либо значение - это становится задачей нелинейной сложности.
Перефразируем наш алгоритм:

<code data-lang="c">#define INDEX 42
#define TOTAL 42
...
if ( value % DIVISOR == 0 ) {
    value -= TOTAL;
    result = some function(value, INDEX);
    if ( result < DIVISOR ) {
        result += TOTAL;
        value - ( result * INDEX );
    }
}</code>
и, внезапно, работать с кодом стало легче. А для внесения изменений в логику необходима аж одна правка и никакого мощного анализа кода.
            </p>
            <h3>Сокращения.</h3>
            <p>
            Да! Имена и названия должны быть лаконичны. Но не доводите до абсурда:
            <code data-lang="c">int func(int prec, int sInd, int pVal) {
    int bRes = prec / sInd;
    int res = bRes * pVal;
    int mOb = bRes + res;
    int sI = bRes + ( res * mOb );

    res = mFuncAr(pVal, sI);

    return res;
}</code>
WTF? Глаза чтеца такого кода истекут кровью!
            </p>
            <p>
                Общепринятые сокращения типа len, lo, hi, avg вполне приемлемы. Но злоупотреблять этим не стоит.
            </p>
            <h3>Литературные изыскания.</h3>
            <p>
            Комментарии в коде - фейл. Фейл конкретный и свидетельствующий о том, что программист даже не надеется разобраться в написанном им же коде через некоторое время.
            Но страшнее всего - очень важные, ценные и уместные замечания в коде. Например:
            <code data-lang="c">int number; //число
int second; //второе число
int result; //Переменная объявлена глобально, чтобы избежать объявления дополнительной переменной.</code>
Зачем подобная информация в коде? В топку! Поклонникам эпистолярного жанра, либо людям с литературным талантом необходимо писать романы. Написанием программ пусть занимаются программисты.
            </p>
        </section>
		<footer>
            <address>
                Автор Caiman.
            </address>
            <time datetime="2013-12-13">18.02.2014</time>
        </footer>
    </article>
    <script type="text/javascript" src="https://dl.dropboxusercontent.com/u/31437201/code.js"></script>
</body>
</html>