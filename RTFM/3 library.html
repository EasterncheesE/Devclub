<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Библиотеки в Си</title>
    <link rel="stylesheet" href="https://dl.dropboxusercontent.com/u/31437201/article.css">
</head>
<body>
    <article class="page">
        <h1>Библиотеки в Си</h1>
        <aside class="plan">
            <div class="contents">
                <h2>План</h2>
                <ol>
                    <li><a href="#intro">Введение</a></li>
                    <li><a href="#create">Создание библиотеки</a></li>
                    <ol>
                        <li><a href="#prototype">Прототипирование функций</a></li>
                        <li><a href="#header_file">Отделение заголовков</a></li>
                        <li><a href="#separate_compilation">Раздельная компиляция</a></li>
                    </ol>
                </ol>
            </div>
            <div class="links">
            </div>
        </aside>

        <section>
            <h2 id="intro">Введение</h2>
            <p>Википедия гласит:</p>
            <blockquote cite="http://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"><dfn>Библиотека</dfn> (от англ. library) в программировании — сборник подпрограмм или объектов, используемых для разработки программного обеспечения (ПО).
            </blockquote>
            <p>В общем случае библиотекой можно назвать любой файл, содержащий вспомогательные функции, макросы и другие элементы программного кода, подключаемый к основной программе на этапе преобразования её в машинный код.</p>
            <p>Библиотеки можно условно разделить на «стандартные», входящие в базовую поставку языка, и «пользовательские», создаваемые непосредственно разработчиком или устанавливаемые дополнительно.</p>
            <p>Создавая и используя свои библиотеки мы преследуем две цели:</p>
            <ul>
                <li>создание универсального набора функций и прочих элементов программного кода, пригодного для использования в разных программах;</li>
                <li>разделение кода на отдельные модули, каждый из которых можно рассматривать и тестировать независимо от других, что упрощает разработку, отладку и поддержку программного кода.</li>
            </ul>
            <p>Нам уже доводилось иметь дело с библиотекой: для того, чтобы пользоваться функциями ввода/вывода в Си нужно подключить стандартную библиотеку ввода/вывода — <code>stdio.h</code>.</p>
        </section>

        <section>
            <h2 id="create">Создание библиотеки</h2>
            <p>Первым шагом в создании своей библиотеки будет вынесение набора функций в отдельный файл с последующим подключением этого файла к основной программе. 
            Рассмотрим простую программу, считывающую массив из файла, разворачивающую этот массив и записывающую результат в другой файл. После выделения отдельных функций получаем следующий файл main.c:</p>
            <code data-lang="c" data-file="main.c">#include &lt;stdio.h&gt;

#define MAX_SIZE 100

int arrayScan(FILE *in, int array[], int limit) {
    int len = 0;

    for ( ; len &lt; limit &amp;&amp; fscanf(in, "%d", &amp;array[len]) == 1; len++ );
    return len;
}

void arrayReverse(int array[], int size) {
    for ( int lo = 0, hi = size - 1; lo &lt; hi; lo++, hi-- ) {
        int buffer = array[lo];

        array[lo] = array[hi];
        array[hi] = buffer;
    }
}

void arrayPrint(FILE *out, int array[], int size) {
    int last = size - 1;

    for ( int i = 0; i &lt; last; i++ ) {
        fprintf(out, "%d ", array[i]);
    }
    fprintf(out, "%d\n", array[last]);
}

int main() {
    FILE *in = fopen("task.in", "r");
    FILE *out = fopen("task.out", "w");
    int array[MAX_SIZE];
    int size;

    size = arrayScan(in, array, MAX_SIZE);
    fclose(in);

    arrayReverse(array, size);
    arrayPrint(out, array, size);
    fclose(out);

    return 0;
}</code>
            <p>Теперь вынесем функции по обработке массива в отдельный файл с названием array.c:</p>
            <code data-lang="c" data-file="array.c">#include &lt;stdio.h&gt;

int arrayScan(FILE *in, int array[], int limit) {
    int len = 0;

    for ( ; len &lt; limit &amp;&amp; fscanf(in, "%d", &amp;array[len]) == 1; len++ );
    return len;
}

void arrayReverse(int array[], int size) {
    for ( int lo = 0, hi = size - 1; lo &lt; hi; lo++, hi-- ) {
        int buffer = array[lo];

        array[lo] = array[hi];
        array[hi] = buffer;
    }
}

void arrayPrint(FILE *out, int array[], int size) {
    int last = size - 1;

    for ( int i = 0; i &lt; last; i++ ) {
        fprintf(out, "%d ", array[i]);
    }
    fprintf(out, "%d\n", array[last]);
}</code>
            <p>Обратите внимание, что в этом файле используются функции для работы с файлами, а следовательно мы должны подключить в нём соответствующую библиотеку. Ну а в нашем файле main.c остаётся следующий код:</p>
            <code data-lang="c" data-file="main.c">#include &lt;stdio.h&gt;

#include "array.c"

#define MAX_SIZE 100

int main() {
    FILE *in = fopen("task.in", "r");
    FILE *out = fopen("task.out", "w");
    int array[MAX_SIZE];
    int size;

    size = arrayScan(in, array, MAX_SIZE);
    fclose(in);

    arrayReverse(array, size);
    arrayPrint(out, array, size);
    fclose(out);

    return 0;
}</code>

            <p>Не смотря на то, что в подключаемом файле array.c уже указано подключение заголовка <code>stdio.h</code>, правилом хорошего тона считается подключение всех библиотек, использованных в том или ином файле.</p>
            <p>Обратите внимание, что при подключении пользовательских библиотек их название указывается в двойных кавычках, а не в угольных скобках. В противном случае компилятор будет искать подключаемую библиотеку не в директории сборки, а по стандартным путям.</p>
            <p>Разумеется, попытка собрать отдельно файл array.c ни к чему хорошему не приведёт, поскольку компилятор не найдёт в нём функцию <code>main()</code>.</p>

            <h3 id="prototype">Прототипирование функций</h3>
            <p>Чем больше функций мы используем, тем чаще возникает ситуация, когда одна функция вызывает другую. Поскольку использование функции возможно исключительно после её объявления, нам становится всё сложнее отслеживать правильный порядок объявления. Крайним случаем можно считать перекрёстную рекурсию, когда две или более функции вызывают друг друга — при этом какую бы функцию мы не объявили первой, код не скомпилируется.</p>
            <code data-lang="c">int foo(int n) {
    if ( n &lt;= 0 ) {
        return 1;
    }
    return n + bar(n-1);
}

int bar(int n) {
    if ( n &lt;= 0 ) {
        return 42;
    }
    return n * foo(n/2);
}</code>
            <p>Решением является отделение объявления функции от её реализации. При этом заголовок функции, не имеющий реализации, называют её <em>прототипом</em>.</p>
            <blockquote cite="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8"><dfn>Прототипом функции</dfn> в языке Си или C++ называется объявление функции, не содержащее тела функции, но указывающее имя функции, арность, типы аргументов и возвращаемый тип данных. В то время как определение функции описывает, что именно делает функция, прототип функции может восприниматься как описание её интерфейса.
            </blockquote>
            <p>Воспользуемся этим приёмом для разрешения нашей перекрёстной проблемы:</p>
            <code data-lang="c">int foo(int);
int bar(int n);

int foo(int n) {
    if ( n &lt;= 0 ) {
        return 1;
    }
    return n + bar(n-1);
}

int bar(int n) {
    if ( n &lt;= 0 ) {
        return 42;
    }
    return n * foo(n/2);
}</code>
            <p class="notabene">Обратите внимание, что указание имени параметра в прототипе не обязательно, однако если такое указание прольёт свет на смысл принимаемых параметров, пренебрегать им не следует.</p>
            <p>Прототип является своеобразным обещанием компилятору, что такая функция будет объявлена в дальнейшем коде. Для того, чтобы это сработало, в прототипе и реализации должны совпадать типы функции и возвращаемых значений, иначе компилятор просто не поймёт, что ему делать.</p>
            <p>Поскольку в прототипе отсутствует исполняемый код, в нём не может содержаться и вызовов других функций. Это избавляет нас от ограничения на очерёдность функций, при условии, что все используемые функции будут объявлены в виде прототипов до их вызова.</p>

            <h3 id="header_file">Отделение заголовков</h3>
            <p>Разделим нашу будущую библиотеку на <em>заголовочный файл</em> (англ. <em>header file</em>) и реализацию. Это даст нам возможность быстро просмотреть содержимое библиотеки, не вникая в детали реализации. Заголовочную информацию, а именно подключаемые библиотеки, макросы и прототипы функций вынесем в файл array.h, а в файле array.c оставим исключительно реализации функций. Таким образом, файл array.h примет следующий вид:</p>
            <code data-lang="c" data-file="array.h">#include &lt;stdio.h&gt;

int  arrayScan(FILE *in, int array[], int limit);
void arrayReverse(int array[], int size);
void arrayPrint(FILE *out, int array[], int size);</code>
            <p>В принципе, имена параметров функций в этом файле не очень нужны, однако следует учесть, что запись <code>int array[]</code> без указания имени примет вид <code>int *</code> — что может быть не вполне понятно в библиотеке по обработке массивов.</p>
            <p>В файле реализаций же оставим подключение только своего заголовка:</p>
            <code data-lang="c" data-file="array.c">#include "array.h"

int arrayScan(FILE *in, int array[], int limit) {
    int len = 0;

    for ( ; len &lt; limit &amp;&amp; fscanf(in, "%d", &amp;array[len]) == 1; len++ );
    return len;
}

void arrayReverse(int array[], int size) {
    for ( int lo = 0, hi = size - 1; lo &lt; hi; lo++, hi-- ) {
        int buffer = array[lo];

        array[lo] = array[hi];
        array[hi] = buffer;
    }
}

void arrayPrint(FILE *out, int array[], int size) {
    int last = size - 1;

    for ( int i = 0; i &lt; last; i++ ) {
        fprintf(out, "%d ", array[i]);
    }
    fprintf(out, "%d\n", array[last]);
}</code>
            <p>Наконец, укажем в нашей основной программе подключение заголовка:</p>
            <code data-lang="c" data-file="main.c">#include &lt;stdio.h&gt;

#include "array.h"

#define MAX_SIZE 100

int main() {
    FILE *in = fopen("task.in", "r");
    FILE *out = fopen("task.out", "w");
    int array[MAX_SIZE];
    int size;

    size = arrayScan(in, array, MAX_SIZE);
    fclose(in);

    arrayReverse(array, size);
    arrayPrint(out, array, size);
    fclose(out);

    return 0;
}</code>
            <p>Может показаться странным, что мы нигде не подключаем файл реализаций array.c. Как же компилятор узнает, откуда ему брать код самих функций? Чтобы разрешить данный вопрос, укажем при компиляции все используемые файлы с исходным кодом (но не заголовки):</p>
            <kbd>gcc -std=c99 main.c array.c</kbd>
            <p>Таким образом при сборке компилятор будет знать из файла заголовков, что в нашем коде будет использоваться определённый набор функций, а код самих функций он возьмёт из array.c</p>
            
            <h3 id="separate_compilation">Раздельная компиляция</h3>
            <p>Раз уж мы планируем использовать нашу библиотеку в разных программах, может быть уместна компиляция отдельно исходного кода функций. Однако, как мы помним, сам по себе файл array.c в исполняемое приложение не соберётся по причине отсутствия в нём основной исполняемой функции. Уместным будет отметить, что сборка на самом деле представляет собой не единый процесс, а несколько более-менее независимых друг от друга фаз. Одна из них, собственно, <a href="http://en.wikipedia.org/wiki/Compiler" target="_blank">компиляция</a> — превращает исходник в исполняемый код, а другая, называемая <a href="http://en.wikipedia.org/wiki/Linker_(computing)" target="_blank">линковкой</a> или же связыванием, производит «крупноблочную» сборку окончательной программы из уже скомпилированных кусков.</p>
            <p>Ключ <code>-с</code> укажет компилятору, что необходимо произвести только компиляцию, без линковки. Это даст возможность скомпилировать отдельно код функций:</p>
            <kbd>gcc -std=c99 -c array.c</kbd>
            <p>На выходе мы получим <a href="http://en.wikipedia.org/wiki/Object_file" target="_blank">объектный файл</a> — array.o. Это скомпилированный код нашей библиотеки. В принципе, аналогичным образом мы можем скомпилировать main.c, не линкуя его с библиотекой:</p>
            <kbd>gcc -c main.c</kbd>
            <p>Осталось лишь слинковать всё вместе:</p>
            <kbd>gcc main.o array.o</kbd>
            <p>Не то что бы для нашей микроскопической библиотеки на три функции раздельная компиляция давала что-то особенное, однако, если речь пойдёт о крупном проекте, заблаговременная сборка отдельных модулей позволит сэкономить время. Ведь при дальнейшей доработке нам придётся компилировать только изменившиеся модули и модули, которые от них зависят. И кроме того, компилируя код библиотеки отдельно от приложения мы можем отследить ошибки в самой библиотеке, абстрагируясь от возможных ошибок в остальных модулях.</p>
        </section>

        <footer>
            <address>
                Автор Embar.
            </address>
            <time datetime="2014-01-29">29.01.2014</time>
        </footer>
    </article>
    <script type="text/javascript" src="https://dl.dropboxusercontent.com/u/31437201/code.js"></script>
</body>
</html>
